-- ========= Servi√ßos =========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")
local LogService = game:GetService("LogService")

-- Limpar logs F9 a cada 5 segundos
task.spawn(function()
	while true do
		task.wait(5)
		pcall(function()
			LogService:ClearOutput()
		end)
	end
end)

-- Silenciar avisos de WaitForChild do jogo
local oldWarn = warn
warn = function(...)
	local msg = tostring(...)
	if not msg:find("Infinite yield") then
		oldWarn(...)
	end
end

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ========= SISTEMA CENTRAL DE ESP =========
local ESPData = {}

-- Fun√ß√£o para verificar se est√° na mesma dimens√£o/mapa
function isInSameDimension(targetCharacter)
	local myChar = LocalPlayer.Character
	if not myChar or not targetCharacter then return false end
	
	-- Verificar se ambos est√£o no mesmo Parent (mesma dimens√£o/mapa)
	local myParent = myChar.Parent
	local targetParent = targetCharacter.Parent
	
	if myParent ~= targetParent then return false end
	
	-- Verifica√ß√£o adicional: verificar se est√£o no mesmo workspace ou folder
	local myRoot = myChar:FindFirstChild("HumanoidRootPart")
	local targetRoot = targetCharacter:FindFirstChild("HumanoidRootPart")
	
	if not myRoot or not targetRoot then return false end
	
	-- Se a dist√¢ncia for absurdamente grande (>10000), provavelmente est√£o em dimens√µes diferentes
	local distance = (targetRoot.Position - myRoot.Position).Magnitude
	if distance > 10000 then return false end
	
	return true
end

function isValidPlayer(player)
	local data = ESPData[player]
	if not data then return false end
	if not data.character or not data.humanoid or not data.root then return false end
	if data.humanoid.Health <= 0 then return false end
	return true
end

-- ========= Configura√ß√µes Globais (Otimiza√ß√£o para reduzir registros locais) =========
ESP_DEFAULT_ON = false
SHOW_NAME_DEFAULT = false
SHOW_HEALTH_DEFAULT = false
SHOW_DISTANCE_DEFAULT = false
SHOW_TRACERS_DEFAULT = false
ESP_POSITION_DEFAULT = "Topo"
ESP_MODE_DEFAULT = "Cheio"
TEAM_FILTER_DEFAULT = "Todos"
ESP_MAX_DISTANCE = 500


-- Aimbot Config Global
aimbotEnabled = true
aimbotFOV = 100
aimbotFOVZero = 0
aimbotSmooth = 5
aimbotTarget = "Cabe√ßa"
aimbotBind = nil
aimbotBindString = "Nenhuma"
aimbotShowFOV = false
aimbotShowFOVZero = false
aimbotOnlyVisible = false
aimbotOnNPCs = false
aimbotMobile = false
aimbotTeamCheck = true

-- Dropdown alvo
targetDropdownOpen = false
targetOptions = {"Cabe√ßa", "Peito"}

UI_TOGGLE_KEY = Enum.KeyCode.M
FREEFLY_TOGGLE_KEY = Enum.KeyCode.F
UNLOCK_MOUSE_KEY = Enum.KeyCode.P

-- Free-Fly manual
FREEFLY_SPEED = 50
FREEFLY_SPRINT_MULT = 2
FREEFLY_VERTICAL_SPEED = 30

-- Limites do painel
PANEL_MIN = Vector2.new(500, 600)
PANEL_MAX = Vector2.new(900, 800)

-- ========= Estado Global (Otimiza√ß√£o) =========
espEnabled = ESP_DEFAULT_ON
showName = SHOW_NAME_DEFAULT
showHealth = SHOW_HEALTH_DEFAULT
showDistance = SHOW_DISTANCE_DEFAULT
showTracers = SHOW_TRACERS_DEFAULT
espPosition = ESP_POSITION_DEFAULT
espMode = ESP_MODE_DEFAULT
teamFilter = TEAM_FILTER_DEFAULT
espAutoEnabled = false

showSkeleton = false
showBox3D = false
showTracers = false
tracerMode = "Sky" -- Sky ou Center
espColor = Color3.fromRGB(255, 0, 0) -- Cor padr√£o das boxes
espTracerColor = Color3.fromRGB(255, 255, 255) -- Cor padr√£o dos tracers (branco)
showEspDistance = false
espDistanceColor = Color3.fromRGB(255, 255, 0) -- Cor padr√£o da dist√¢ncia (amarelo)

boxes = {}           -- [Character] = BoxHandles
tracers = {}         -- [Character] = Line
distanceLabels = {}  -- [Character] = Drawing.Text
nameLabels = {}      -- [Character] = Drawing.Text
healthBars = {}      -- [Character] = {bg, fill} - Barras de vida 2D
espNameColor = Color3.fromRGB(255, 255, 255) -- Cor padr√£o do nome (branco)

-- Player enhancements globais
speedBoostEnabled = false
speedBoostValue = 50
jumpPowerBoostEnabled = false
jumpPowerBoostValue = 100
infiniteJumpEnabled = false
antiKickEnabled = false

-- Valores originais
originalWalkSpeed = 16
originalJumpPower = 50

highlights = {}         -- [Character] = Highlight
overlays = {}           -- [Character] = BillboardGui


-- Fly-to target
flightConn = nil
flightStartTime = 0
cancelling = false
noclipActive = false
savedCollide = {}

-- Free-fly manual
freeflyOn = false
freeflyConn = nil
inputStates = {W=false,A=false,S=false,D=false,Space=false,Shift=false,Ctrl=false}
freeflyStartCFrame = nil

-- UI state
panelVisible = false
prevMouseBehavior = nil
prevMouseIconEnabled = nil

-- Spectate
spectating = nil
savedSubject = nil
savedCamType = nil
spectateConn = nil
spectateTracerLine = nil

-- Grab system
grabbing = false
grabbedPlayer = nil
grabConn = nil
GRAB_DISTANCE = 3
GRAB_HEIGHT = 0

-- Kill Player System
killingPlayer = false
killConnection = nil
killTargetPlayer = nil
killRangeEnabled = true
killCycleState = 0
killCycleTimer = 0

-- Auto Kill Stats
autoKillStats = {
	enemiesAlive = 0,
	enemiesKilled = 0,
	roundTimer = 0,
	waitingForRound = false
}

function countEnemies()
	local count = 0
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local hum = player.Character:FindFirstChildOfClass("Humanoid")
			if hum and hum.Health > 0 and isInSameDimension(player.Character) and isEnemy(player) then
				count = count + 1
			end
		end
	end
	return count
end

function getRoundTimer()
	local gui = LocalPlayer:FindFirstChild("PlayerGui")
	if not gui then return nil end
	
	for _, desc in ipairs(gui:GetDescendants()) do
		if desc:IsA("TextLabel") or desc:IsA("TextBox") then
			local text = desc.Text
			local timer = tonumber(text:match("(%d+)"))
			if timer and timer <= 60 then
				return timer
			end
		end
	end
	return nil
end

function findWeaponOrKnife()
	local character = LocalPlayer.Character
	if not character then return nil end
	
	for _, tool in pairs(character:GetChildren()) do
		if tool:IsA("Tool") then return tool end
	end
	
	local backpack = LocalPlayer:FindFirstChild("Backpack")
	if backpack then
		for _, tool in pairs(backpack:GetChildren()) do
			if tool:IsA("Tool") then return tool end
		end
	end
	return nil
end

function extendToolRange(tool, range)
	if not tool then return end
	local handle = tool:FindFirstChild("Handle")
	if handle and handle:IsA("BasePart") then
		handle.Size = Vector3.new(0.5, 0.5, range or 30)
		handle.Massless = true
		handle.Transparency = 1
	end
end

function stopKilling()
	if killConnection then
		killConnection:Disconnect()
		killConnection = nil
	end
	killingPlayer = false
	killTargetPlayer = nil
	killCycleState = 0
	killCycleTimer = 0
end

function killPlayer(targetPlayer)
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	if not targetPlayer.Character then return end
	
	local character = LocalPlayer.Character
	if not character then return end
	
	local myRoot = character:FindFirstChild("HumanoidRootPart")
	if not myRoot then return end
	
	local weapon = findWeaponOrKnife()
	if weapon and weapon.Parent ~= character then
		weapon.Parent = character
		task.wait(0.05)
	end
	
	if weapon and killRangeEnabled then
		extendToolRange(weapon, 35)
	end
	
	stopKilling()
	
	killingPlayer = true
	killTargetPlayer = targetPlayer
	killCycleState = 0
	killCycleTimer = 0
	
	killConnection = RunService.Heartbeat:Connect(function(dt)
		if not killingPlayer or not killTargetPlayer then
			stopKilling()
			return
		end
		
		local char = LocalPlayer.Character
		local tChar = killTargetPlayer.Character
		
		if not char or not tChar then
			stopKilling()
			return
		end
		
		local root = char:FindFirstChild("HumanoidRootPart")
		local tRoot = tChar:FindFirstChild("HumanoidRootPart")
		local tHum = tChar:FindFirstChildOfClass("Humanoid")
		
		if not root or not tRoot or not tHum or tHum.Health <= 0 then
			stopKilling()
			return
		end
		
		killCycleTimer = killCycleTimer + dt
		
		if killCycleState == 0 then
			local targetPos = tRoot.Position
			root.CFrame = CFrame.new(targetPos) * CFrame.new(0, 0, 2)
			root.AssemblyLinearVelocity = Vector3.zero
			
			local wpn = findWeaponOrKnife()
			if wpn and wpn.Parent == char then
				if killRangeEnabled then
					extendToolRange(wpn, 35)
				end
				wpn:Activate()
			end
			
			if killCycleTimer >= 0.7 then
				killCycleState = 1
				killCycleTimer = 0
			end
		else
			root.CFrame = CFrame.new(tRoot.Position.X, -600, tRoot.Position.Z)
			root.AssemblyLinearVelocity = Vector3.zero
			
			if killCycleTimer >= 0.25 then
				killCycleState = 0
				killCycleTimer = 0
			end
		end
	end)
end

-- Bugar systems
buggingPlayers = {}
bugConn = nil
buggingCars = {}
bugCarConn = nil

-- Player selection
selectedPlayer = nil
playerButtons = {}

-- Search system
searchQuery = ""
searchBox = nil
isTypingInSearch = false

-- ========= FUN√á√ïES AUXILIARES PARA LISTA DE JOGADORES =========
function getPlayerTeam(player)
	if not player.Team then return "Sem Equipe" end
	return player.Team.Name
end

function getPlayerTeamColor(player)
	if not player.Team then return Color3.fromRGB(128, 128, 128) end
	return player.TeamColor.Color
end

function getPlayerHealth(player)
	local char = player.Character
	if not char then return nil end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return nil end
	return hum.Health
end

function getPlayerMaxHealth(player)
	local char = player.Character
	if not char then return nil end
	local hum = char:FindFirstChildOfClass("Humanoid")
	if not hum then return nil end
	return hum.MaxHealth
end

function getPlayerDistance(player)
	local char = player.Character
	local myChar = LocalPlayer.Character
	if not char or not myChar then return nil end

	local myRoot = getPrimaryPart(myChar)
	local targetRoot = getPrimaryPart(char)
	if not myRoot or not targetRoot then return nil end

	return math.floor((targetRoot.Position - myRoot.Position).Magnitude + 0.5)
end

function isPlayerAlive(player)
	local health = getPlayerHealth(player)
	return health and health > 0
end

function formatPlayerInfo(player)
	local displayName = player.DisplayName or player.Name
	local username = player.Name
	local team = getPlayerTeam(player)
	local distance = getPlayerDistance(player)
	local health = getPlayerHealth(player)
	local maxHealth = getPlayerMaxHealth(player)
	local alive = isPlayerAlive(player)

	local info = string.format("%s (@%s)", displayName, username)
	if team ~= "Sem Equipe" then
		info = info .. string.format(" | %s", team)
	end
	if distance then
		info = info .. string.format(" | %dm", distance)
	end
	if health and maxHealth then
		info = info .. string.format(" | HP: %d/%d", math.floor(health), math.floor(maxHealth))
	end
	if not alive then
		info = info .. " | üíÄ MORTO"
	end

	return info
end

-- Fun√ß√£o para atualizar um bot√£o de jogador espec√≠fico
function updatePlayerButton(player, button)
	if not button or not button.Parent then return end

	local mainContainer = button:FindFirstChild("MainContainer")
	if not mainContainer then return end

	local infoLabel = mainContainer:FindFirstChild("InfoLabel")
	local teamIndicator = mainContainer:FindFirstChild("TeamIndicator")
	local healthBarBg = mainContainer:FindFirstChild("HealthBarBg")
	local statusLabel = mainContainer:FindFirstChild("StatusLabel")

	-- Atualizar informa√ß√µes secund√°rias
	if infoLabel then
		infoLabel.Text = formatPlayerInfo(player)
	end

	-- Atualizar indicador de equipe
	if teamIndicator then
		teamIndicator.BackgroundColor3 = getPlayerTeamColor(player)
	end

	-- Atualizar barra de vida
	if healthBarBg then
		local healthBar = healthBarBg:FindFirstChild("HealthBar")
		if healthBar then
			local health = getPlayerHealth(player)
			local maxHealth = getPlayerMaxHealth(player)
			local healthPercent = maxHealth and health and (health / maxHealth) or 0

			healthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
			healthBar.BackgroundColor3 = healthPercent > 0.5 and Color3.fromRGB(0, 255, 0) or healthPercent > 0.25 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 0, 0)
		end
	end

	-- Atualizar status
	if statusLabel then
		local alive = isPlayerAlive(player)
		statusLabel.TextColor3 = alive and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
		statusLabel.Text = alive and "VIVO" or "MORTO"
	end
end

-- Sistema de atualiza√ß√£o em tempo real (DESABILITADO para n√£o interferir na pesquisa)
function startRealTimeUpdates()
	-- Desabilitado para evitar recarregar lista durante pesquisa
end

-- ========= SISTEMA DE BIND DE CHARACTER =========
function bindCharacter(player, character)
	local humanoid = character:WaitForChild("Humanoid", 5)
	local root = character:WaitForChild("HumanoidRootPart", 5)
	if not humanoid or not root then return end

	local data = ESPData[player]
	if not data then return end

	data.character = character
	data.humanoid = humanoid
	data.root = root

	if data.init and espEnabled then
		data.init(character)
	end
end

function setupPlayer(player)
	if player == LocalPlayer then return end

	ESPData[player] = {
		character = nil,
		humanoid = nil,
		root = nil,

		init = function(character)
			ensureHighlight(character)
			ensureBox3D(character)
			if showHealth then
				ensureHealthBar(character)
			end
		end,

		hide = function()
			local char = player.Character
			if not char then return end
			
			if highlights[char] then
				highlights[char].Enabled = false
			end
			if overlays[char] then
				overlays[char].Enabled = false
			end
			if boxes[char] then
				for _, line in pairs(boxes[char]) do
					if line then line.Visible = false end
				end
			end
			if nameLabels[char] then
				nameLabels[char].Visible = false
			end
			if distanceLabels[char] then
				distanceLabels[char].Visible = false
			end
		end,

		cleanup = function()
			local char = player.Character
			if char then
				pcall(function()
					if highlights[char] then
						highlights[char]:Destroy()
						highlights[char] = nil
					end
					if overlays[char] then
						overlays[char]:Destroy()
						overlays[char] = nil
					end
					if boxes[char] then
						for _, line in pairs(boxes[char]) do
							if line then line:Remove() end
						end
						boxes[char] = nil
					end
					if tracers[char] then
						tracers[char]:Remove()
						tracers[char] = nil
					end
					if nameLabels[char] then
						nameLabels[char]:Remove()
						nameLabels[char] = nil
					end
					if distanceLabels[char] then
						distanceLabels[char]:Remove()
						distanceLabels[char] = nil
					end
				end)
			end
		end
	}

	player.CharacterAdded:Connect(function(character)
		bindCharacter(player, character)
	end)

	player.CharacterRemoving:Connect(function()
		local data = ESPData[player]
		if not data then return end
		data.character = nil
		data.humanoid = nil
		data.root = nil
		if data.cleanup then
			data.cleanup()
		end
	end)

	if player.Character then
		bindCharacter(player, player.Character)
	end
end

-- Conectar eventos de mudan√ßa de equipe
function setupPlayerEvents(player)
	if not player then return end

	player:GetPropertyChangedSignal("Team"):Connect(function()
		local button = playerButtons[player]
		if button then
			updatePlayerButton(player, button)
		end
	end)

	player.CharacterAdded:Connect(function(character)
		task.wait(0.1)
		local button = playerButtons[player]
		if button then
			updatePlayerButton(player, button)
		end
	end)

	player.CharacterRemoving:Connect(function()
		local button = playerButtons[player]
		if button then
			updatePlayerButton(player, button)
		end
	end)
end

local function createPlayerButton(player)
	if not player or player == LocalPlayer then return end

	local btn = Instance.new("Frame")
	btn.Name = player.Name .. "_Enhanced"
	btn.Size = UDim2.new(1, -10, 0, 60) -- Maior para mais informa√ß√µes
	btn.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
	btn.Parent = playersList
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 8)

	-- Indicador de sele√ß√£o lateral
	local selectionIndicator = Instance.new("Frame")
	selectionIndicator.Size = UDim2.new(0, 4, 1, -8)
	selectionIndicator.Position = UDim2.new(0, 2, 0, 4)
	selectionIndicator.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	selectionIndicator.Visible = false
	selectionIndicator.Parent = btn
	Instance.new("UICorner", selectionIndicator).CornerRadius = UDim.new(0, 2)

	-- Avatar do jogador
	local avatar = Instance.new("ImageLabel")
	avatar.Size = UDim2.new(0, 50, 0, 50)
	avatar.Position = UDim2.new(0, 5, 0, 5)
	avatar.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	avatar.BorderSizePixel = 0
	avatar.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
	avatar.Parent = btn
	Instance.new("UICorner", avatar).CornerRadius = UDim.new(1, 0)

	-- Container principal
	local mainContainer = Instance.new("Frame")
	mainContainer.Size = UDim2.new(1, -68, 1, 0)
	mainContainer.Position = UDim2.new(0, 62, 0, 0)
	mainContainer.BackgroundTransparency = 1
	mainContainer.Parent = btn

	-- Nome e Display Name
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.6, 0, 0, 20)
	nameLabel.Position = UDim2.new(0, 0, 0, 2)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.GothamBold
	nameLabel.TextSize = 14
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = player.DisplayName .. " (@" .. player.Name .. ")"
	nameLabel.Parent = mainContainer

	-- Informa√ß√µes secund√°rias (equipe, dist√¢ncia, vida)
	local infoLabel = Instance.new("TextLabel")
	infoLabel.Size = UDim2.new(0.6, 0, 0, 16)
	infoLabel.Position = UDim2.new(0, 0, 0, 22)
	infoLabel.BackgroundTransparency = 1
	infoLabel.Font = Enum.Font.SourceSans
	infoLabel.TextSize = 12
	infoLabel.TextColor3 = Color3.fromRGB(200, 200, 200)
	infoLabel.TextXAlignment = Enum.TextXAlignment.Left
	infoLabel.Text = formatPlayerInfo(player)
	infoLabel.Parent = mainContainer

	-- Indicador de equipe (canto superior direito)
	local teamIndicator = Instance.new("Frame")
	teamIndicator.Size = UDim2.new(0, 12, 0, 12)
	teamIndicator.Position = UDim2.new(1, -16, 0, 4)
	teamIndicator.BackgroundColor3 = getPlayerTeamColor(player)
	teamIndicator.Parent = mainContainer
	Instance.new("UICorner", teamIndicator).CornerRadius = UDim.new(1, 0)

	-- Barra de vida (parte inferior)
	local healthBarBg = Instance.new("Frame")
	healthBarBg.Size = UDim2.new(0.6, 0, 0, 6)
	healthBarBg.Position = UDim2.new(0, 0, 0, 42)
	healthBarBg.BackgroundColor3 = Color3.fromRGB(60, 60, 60)
	healthBarBg.Parent = mainContainer
	Instance.new("UICorner", healthBarBg).CornerRadius = UDim.new(0, 3)

	local health = getPlayerHealth(player)
	local maxHealth = getPlayerMaxHealth(player)
	local healthPercent = maxHealth and health and (health / maxHealth) or 0

	local healthBar = Instance.new("Frame")
	healthBar.Size = UDim2.new(healthPercent, 0, 1, 0)
	healthBar.BackgroundColor3 = healthPercent > 0.5 and Color3.fromRGB(0, 255, 0) or healthPercent > 0.25 and Color3.fromRGB(255, 255, 0) or Color3.fromRGB(255, 0, 0)
	healthBar.Parent = healthBarBg
	Instance.new("UICorner", healthBar).CornerRadius = UDim.new(0, 3)

	-- Status de vida (canto inferior direito)
	local statusLabel = Instance.new("TextLabel")
	statusLabel.Size = UDim2.new(0.35, 0, 0, 16)
	statusLabel.Position = UDim2.new(0.65, 0, 0, 40)
	statusLabel.BackgroundTransparency = 1
	statusLabel.Font = Enum.Font.SourceSansBold
	statusLabel.TextSize = 10
	statusLabel.TextColor3 = isPlayerAlive(player) and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
	statusLabel.TextXAlignment = Enum.TextXAlignment.Right
	statusLabel.Text = isPlayerAlive(player) and "VIVO" or "MORTO"
	statusLabel.Parent = mainContainer

	-- Bot√£o invis√≠vel para cliques
	local clickBtn = Instance.new("TextButton")
	clickBtn.Size = UDim2.new(1, 0, 1, 0)
	clickBtn.BackgroundTransparency = 1
	clickBtn.Text = ""
	clickBtn.Parent = btn

	clickBtn.MouseButton1Click:Connect(function()
		-- Desselecionar anterior
		for _, button in pairs(playerButtons) do
			if button:IsA("Frame") then
				local indicator = button:FindFirstChild("SelectionIndicator")
				if indicator then
					indicator.Visible = false
					button.BackgroundColor3 = Color3.fromRGB(45, 45, 55)
				end
			end
		end

		-- Selecionar atual
		selectionIndicator.Visible = true
		btn.BackgroundColor3 = Color3.fromRGB(60, 60, 75)
		selectedPlayer = player

		-- Mostrar painel de a√ß√µes
		if actionsPanel then
			actionsPanel.Visible = true
			if tpBtn then tpBtn.Visible = true end
			if spectateBtn then spectateBtn.Visible = true end
			if spectateToggle then spectateToggle.Visible = true end
			if killBtn then killBtn.Visible = true end
		end
	end)

	playerButtons[player] = btn
	return btn
end

function buildPlayersOnce()
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer and not playerButtons[p] then
			createPlayerButton(p)
		end
	end
end



Players.PlayerRemoving:Connect(function(p)
	if playerButtons[p] then
		playerButtons[p]:Destroy()
		playerButtons[p] = nil
	end
	if selectedPlayer == p then
		selectedPlayer = nil
		actionsPanel.Visible = false
	end
end)

function filterPlayersBySearch(query)
	searchQuery = query:lower()
	for player, button in pairs(playerButtons) do
		if button and button.Parent then
			local playerName = player.Name:lower()
			local displayName = (player.DisplayName or ""):lower()
			local matches = playerName:find(searchQuery, 1, true) or displayName:find(searchQuery, 1, true)
			button.Visible = (searchQuery == "" or matches ~= nil)
		end
	end
end

function applySearch(text)
	filterPlayersBySearch(text)
end



-- ========= NOVO SISTEMA DE FLY/NOCLIP =========
local FlySystem = {
    flying = false,
    noclip = false,
    speed = 1,  -- Come√ßa com velocidade 1
    bodyGyro = nil,
    bodyVelocity = nil,
    control = {F = 0, B = 0, L = 0, R = 0, U = 0, D = 0}
}

-- Fun√ß√£o para ativar/desativar Fly
function FlySystem:toggleFly()
    self.flying = not self.flying

    local character = LocalPlayer.Character
    if not character then return end

    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoidRootPart or not humanoid then return end

    -- Criar ou remover controles de voo
    if self.flying then
        -- Ativar Fly
        self.bodyGyro = Instance.new("BodyGyro", humanoidRootPart)
        self.bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
        self.bodyGyro.D = 1000
        self.bodyGyro.CFrame = humanoidRootPart.CFrame

        self.bodyVelocity = Instance.new("BodyVelocity", humanoidRootPart)
        self.bodyVelocity.MaxForce = Vector3.new(400000, 400000, 400000)
        self.bodyVelocity.Velocity = Vector3.new(0, 0, 0)
    else
        -- Desativar Fly e restaurar transpar√™ncia
        if self.bodyGyro then self.bodyGyro:Destroy() end
        if self.bodyVelocity then self.bodyVelocity:Destroy() end
        self.bodyGyro = nil
        self.bodyVelocity = nil
    end
end

-- Fun√ß√£o para ativar/desativar Noclip
function FlySystem:toggleNoclip()
    self.noclip = not self.noclip
end

-- Fun√ß√£o para ajustar velocidade do Fly
function FlySystem:setSpeed(newSpeed)
    self.speed = math.clamp(newSpeed, 1, 100)
end

-- Configurar controles de teclado
function FlySystem:setupControls()
    -- Controles de movimento
    UserInputService.InputBegan:Connect(function(input, gpe)
        if gpe then return end

        if input.KeyCode == Enum.KeyCode.W then self.control.F = 1 end
        if input.KeyCode == Enum.KeyCode.S then self.control.B = 1 end
        if input.KeyCode == Enum.KeyCode.A then self.control.L = 1 end
        if input.KeyCode == Enum.KeyCode.D then self.control.R = 1 end
        if input.KeyCode == Enum.KeyCode.Space then self.control.U = 1 end
        if input.KeyCode == Enum.KeyCode.LeftControl then self.control.D = 1 end

        -- Teclas extras para controle de velocidade
        if input.KeyCode == Enum.KeyCode.Equals then
            self:setSpeed(self.speed + 5)
        elseif input.KeyCode == Enum.KeyCode.Minus then
            self:setSpeed(self.speed - 5)
        end
    end)

    UserInputService.InputEnded:Connect(function(input, gpe)
        if gpe then return end

        if input.KeyCode == Enum.KeyCode.W then self.control.F = 0 end
        if input.KeyCode == Enum.KeyCode.S then self.control.B = 0 end
        if input.KeyCode == Enum.KeyCode.A then self.control.L = 0 end
        if input.KeyCode == Enum.KeyCode.D then self.control.R = 0 end
        if input.KeyCode == Enum.KeyCode.Space then self.control.U = 0 end
        if input.KeyCode == Enum.KeyCode.LeftControl then self.control.D = 0 end
    end)
end

-- Loop principal de Fly
function FlySystem:startLoop()
    RunService.RenderStepped:Connect(function()
        local character = LocalPlayer.Character
        if not character then return end

        local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
        local humanoid = character:FindFirstChild("Humanoid")
        if not humanoidRootPart then return end

        -- Sistema Noclip
        if self.noclip then
            for _, v in pairs(character:GetDescendants()) do
                if v:IsA("BasePart") and v.CanCollide == true then
                    v.CanCollide = false
                end
            end
        end

        -- Sistema Fly
        if self.flying and humanoidRootPart then
            -- Desabilitar anima√ß√£o de queda
            if humanoid then
                humanoid:ChangeState(Enum.HumanoidStateType.Flying)
            end

            local cam = workspace.CurrentCamera
            local moveVec = Vector3.zero

            local forward = cam.CFrame.LookVector
            local right = cam.CFrame.RightVector
            local up = Vector3.new(0, 1, 0)

            -- Calcular dire√ß√£o do movimento
            moveVec = moveVec
                + forward * (self.control.F - self.control.B)
                + right * (self.control.R - self.control.L)
                + up * (self.control.U - self.control.D)

            -- Aplicar movimento
            if moveVec.Magnitude > 0 then
                moveVec = moveVec.Unit * self.speed
                humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveVec
            end
        end
    end)
end

-- Fun√ß√£o para resetar ao respawnar
function FlySystem:setupCharacterEvents()
    local function onCharacterAdded(char)
        -- Resetar fly e noclip ao respawnar
        self.flying = false
        self.noclip = false

        -- Limpar controles antigos
        if self.bodyGyro then self.bodyGyro:Destroy() end
        if self.bodyVelocity then self.bodyVelocity:Destroy() end
        self.bodyGyro = nil
        self.bodyVelocity = nil
    end

    LocalPlayer.CharacterAdded:Connect(onCharacterAdded)
    if LocalPlayer.Character then
        onCharacterAdded(LocalPlayer.Character)
    end
end

-- Inicializar sistema completo
function FlySystem:init()
    self:setupControls()
    self:setupCharacterEvents()
    self:startLoop()

    return self
end

-- Inicializar o sistema
FlySystem:init()

-- Vari√°veis globais para compatibilidade - Sincronizadas
flying = FlySystem.flying
noclip = FlySystem.noclip
speed = FlySystem.speed

-- Fun√ß√µes de compatibilidade - Atualizam globais
function toggleFly()
    FlySystem:toggleFly()
    flying = FlySystem.flying
    noclip = FlySystem.noclip  -- Noclip √© ativado automaticamente com fly
end

function toggleNoclip()
    FlySystem:toggleNoclip()
    noclip = FlySystem.noclip
end

-- ========= Fun√ß√£o para Destravar Mouse =========
function unlockMouse()
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true

	if panelVisible then
		showPanel(false)
	end

	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local notification = Instance.new("ScreenGui")
	notification.Name = "MouseUnlockNotification"
	notification.ResetOnSpawn = false
	notification.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	notification.Parent = playerGui

	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 300, 0, 80)
	frame.Position = UDim2.new(0.5, -150, 0.1, 0)
	frame.BackgroundColor3 = Color3.fromRGB(0, 100, 0)
	frame.BorderSizePixel = 0
	frame.Parent = notification
	Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "üîì MOUSE DESTRAVADO!\nTecla P pressionada"
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Font = Enum.Font.GothamBold
	label.TextSize = 16
	label.TextWrapped = true
	label.Parent = frame

	-- Remover ap√≥s 3 segundos
	task.delay(3, function()
		notification:Destroy()
	end)
end

-- ========= Helpers =========
function getPrimaryPart(char)
	if not char then return nil end
	return char.PrimaryPart
		or char:FindFirstChild("HumanoidRootPart")
		or char:FindFirstChild("Torso")
		or char:FindFirstChild("UpperTorso")
end

function getHead(char)
	if not char then return nil end
	return char:FindFirstChild("Head") or getPrimaryPart(char)
end

function forEachCharacterPart(char, fn)
	for _, d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then fn(d) end
	end
end

function isEnemy(p)
	-- Verificar se n√£o √© voc√™ mesmo
	if p == LocalPlayer then return false end
	
	-- Se team check estiver desativado, todos s√£o inimigos
	if not aimbotTeamCheck then return true end
	
	-- Se team check estiver ativado, verificar equipe
	if not LocalPlayer.Team or not p.Team then
		-- Se algum jogador n√£o tem equipe, considerar inimigo
		return true
	end
	
	-- Retornar true se estiverem em equipes diferentes
	return LocalPlayer.Team ~= p.Team
end

function applyHighlightMode(highlight)
	if espMode == "Cheio" then
		highlight.FillTransparency = 0
		highlight.OutlineTransparency = 0
	else
		highlight.FillTransparency = 1
		highlight.OutlineTransparency = 0
	end
end

function ensureHighlight(character)
	if not character or not character.Parent then
		if highlights[character] then
			pcall(function() highlights[character]:Destroy() end)
			highlights[character] = nil
		end
		return
	end
	
	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if highlights[character] then
			pcall(function() highlights[character]:Destroy() end)
			highlights[character] = nil
		end
		return
	end
	
	if not espEnabled then
		if highlights[character] then
			pcall(function() highlights[character]:Destroy() end)
			highlights[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia ANTES de criar
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if highlights[character] then
					pcall(function() highlights[character]:Destroy() end)
					highlights[character] = nil
				end
				return
			end
		end
	end
	
	-- Criar highlight se n√£o existir
	local h = highlights[character]
	if not h or not h.Parent then
		h = Instance.new("Highlight")
		h.Name = "PlayerESP"
		h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		h.Adornee = character
		h.Parent = LocalPlayer:WaitForChild("PlayerGui")
		highlights[character] = h
	end

	-- Sistema: verifica se est√° na tela E se n√£o tem parede
	local camera = workspace.CurrentCamera
	local isVisible = false
	
	if camera and espAutoEnabled then
		local targetRoot = getPrimaryPart(character)
		if targetRoot and myChar then
			-- 1. Verificar se est√° na tela
			local screenPos, onScreen = camera:WorldToViewportPoint(targetRoot.Position)
			
			if onScreen then
				-- 2. Verificar se n√£o tem parede no meio (raycast)
				local myRoot = getPrimaryPart(myChar)
				if myRoot then
					local direction = (targetRoot.Position - camera.CFrame.Position)
					local rayParams = RaycastParams.new()
					rayParams.FilterDescendantsInstances = {myChar, character}
					rayParams.FilterType = Enum.RaycastFilterType.Blacklist
					
					local rayResult = workspace:Raycast(camera.CFrame.Position, direction, rayParams)
					
					-- Se n√£o bateu em nada OU bateu no pr√≥prio character = vis√≠vel
					isVisible = not rayResult or rayResult.Instance:IsDescendantOf(character)
				end
			end
		end
	end

	if espAutoEnabled then
		-- Verde se vis√≠vel na tela SEM parede, vermelho se n√£o
		h.FillColor = isVisible and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
		h.OutlineColor = isVisible and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0)
	else
		-- Cor padr√£o para TODOS os jogadores
		h.FillColor = Color3.fromRGB(255, 0, 0)
		h.OutlineColor = Color3.fromRGB(255, 255, 255)
	end
	
	-- SEMPRE aplicar modo se showSkeleton estiver ativo
	if showSkeleton then
		applyHighlightMode(h)
		h.Enabled = true
	else
		h.Enabled = false
	end
end

-- Fun√ß√£o separada para exibir dist√¢ncia (embaixo da box)
function ensureDistanceLabel(character)
	if not character or not character.Parent then
		if distanceLabels[character] then
			pcall(function() distanceLabels[character]:Remove() end)
			distanceLabels[character] = nil
		end
		return
	end
	
	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if distanceLabels[character] then
			pcall(function() distanceLabels[character]:Remove() end)
			distanceLabels[character] = nil
		end
		return
	end
	
	if not espEnabled or not showEspDistance then
		if distanceLabels[character] then
			pcall(function() distanceLabels[character]:Remove() end)
			distanceLabels[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia m√°xima
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if distanceLabels[character] then
					pcall(function() distanceLabels[character]:Remove() end)
					distanceLabels[character] = nil
				end
				return
			end
		end
	end
	
	local root = getPrimaryPart(character)
	if not root then
		if distanceLabels[character] then
			distanceLabels[character].Visible = false
		end
		return
	end
	
	local camera = workspace.CurrentCamera
	local bottomPos = root.Position - Vector3.new(0, 3, 0)
	local screenPos, onScreen = camera:WorldToViewportPoint(bottomPos)
	
	if not onScreen then
		if distanceLabels[character] then
			distanceLabels[character].Visible = false
		end
		return
	end
	
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local dist = math.floor((targetRoot.Position - myRoot.Position).Magnitude)
			local label = distanceLabels[character]
			if not label then
				label = Drawing.new("Text")
				label.Size = 14
				label.Center = true
				label.Outline = true
				distanceLabels[character] = label
			end
			label.Text = dist .. "m"
			label.Color = espDistanceColor
			label.Position = Vector2.new(screenPos.X, screenPos.Y + 5)
			label.Visible = true
		end
	end
end

-- Fun√ß√£o para exibir nome (em cima da box)
function ensureNameLabel(character, player)
	if not character or not character.Parent or not player or not player.Parent then
		if nameLabels[character] then
			pcall(function() nameLabels[character]:Remove() end)
			nameLabels[character] = nil
		end
		return
	end
	
	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if nameLabels[character] then
			pcall(function() nameLabels[character]:Remove() end)
			nameLabels[character] = nil
		end
		return
	end
	
	if not espEnabled or not showName then
		if nameLabels[character] then
			pcall(function() nameLabels[character]:Remove() end)
			nameLabels[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if nameLabels[character] then
					pcall(function() nameLabels[character]:Remove() end)
					nameLabels[character] = nil
				end
				return
			end
		end
	end
	
	local root = getPrimaryPart(character)
	if not root then
		if nameLabels[character] then
			nameLabels[character].Visible = false
		end
		return
	end
	
	local camera = workspace.CurrentCamera
	local topPos = root.Position + Vector3.new(0, 3, 0)
	local screenPos, onScreen = camera:WorldToViewportPoint(topPos)
	
	if not onScreen then
		if nameLabels[character] then
			nameLabels[character].Visible = false
		end
		return
	end
	
	local label = nameLabels[character]
	if not label then
		label = Drawing.new("Text")
		label.Size = 14
		label.Center = true
		label.Outline = true
		nameLabels[character] = label
	end
	label.Text = player.Name
	label.Color = espNameColor
	label.Position = Vector2.new(screenPos.X, screenPos.Y - 10)
	label.Visible = true
end

-- Box 3D est√°tica que sempre fica virada para voc√™
function ensureBox3D(character)
	if not character or not character.Parent then
		if boxes[character] then
			pcall(function() boxes[character]:Destroy() end)
			boxes[character] = nil
		end
		return
	end

	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if boxes[character] then
			pcall(function() boxes[character]:Destroy() end)
			boxes[character] = nil
		end
		return
	end

	if not showBox3D or not espEnabled then
		if boxes[character] then
			pcall(function() boxes[character]:Destroy() end)
			boxes[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if boxes[character] then
					pcall(function() boxes[character]:Destroy() end)
					boxes[character] = nil
				end
				return
			end
		end
	end

	local head = character:FindFirstChild("Head")
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	if not head or not humanoidRootPart then return end

	-- Criar BillboardGui se n√£o existir
	if not boxes[character] then
		local billboard = Instance.new("BillboardGui")
		billboard.Name = "ESP_Box"
		billboard.Adornee = humanoidRootPart
		billboard.Size = UDim2.new(4.5, 0, 7, 0) -- Maior para n√£o cortar nas bordas
		billboard.StudsOffset = Vector3.new(0, 0, 0) -- Centralizado
		billboard.AlwaysOnTop = true
		billboard.Parent = humanoidRootPart
		
		-- Frame da box
		local frame = Instance.new("Frame")
		frame.Size = UDim2.new(1, 0, 1, 0)
		frame.BackgroundTransparency = 1
		frame.Parent = billboard
		
		-- Criar bordas
		local stroke = Instance.new("UIStroke")
		stroke.Color = espColor
		stroke.Thickness = 2
		stroke.Parent = frame
		
		boxes[character] = billboard
	end
	
	-- Atualizar cor
	local billboard = boxes[character]
	if billboard and billboard.Parent then
		local frame = billboard:FindFirstChildOfClass("Frame")
		if frame then
			local stroke = frame:FindFirstChildOfClass("UIStroke")
			if stroke then
				stroke.Color = espColor
			end
		end
	end
end

-- Tracers com modos Sky e Center
function ensureTracer(character)
	if not character or not character.Parent then
		if tracers[character] then
			pcall(function() tracers[character]:Remove() end)
			tracers[character] = nil
		end
		return
	end
	
	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if tracers[character] then
			pcall(function() tracers[character]:Remove() end)
			tracers[character] = nil
		end
		return
	end
	
	if not showTracers or not espEnabled then
		if tracers[character] then
			pcall(function() tracers[character]:Remove() end)
			tracers[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if tracers[character] then
					pcall(function() tracers[character]:Remove() end)
					tracers[character] = nil
				end
				return
			end
		end
	end
	
	local tracer = tracers[character]
	if not tracer then
		tracer = Drawing.new("Line")
		tracer.Thickness = 1
		tracer.Transparency = 1
		tracers[character] = tracer
	end
	
	-- Usar cor independente dos tracers
	tracer.Color = espTracerColor
	tracer.Thickness = 1
	
	local torso = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	if not torso then
		tracer.Visible = false
		return
	end
	
	local camera = workspace.CurrentCamera
	local chestPos = torso.Position
	local chestScreen, chestOnScreen = camera:WorldToViewportPoint(chestPos)
	
	if not chestOnScreen then
		tracer.Visible = false
		return
	end
	
	if tracerMode == "Center" then
		-- Center: Do ch√£o (parte inferior central da tela) at√© o peito
		tracer.From = Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y)
		tracer.To = Vector2.new(chestScreen.X, chestScreen.Y)
		tracer.Visible = true
	else
		-- Sky: Do topo (parte superior central da tela) at√© o peito
		tracer.From = Vector2.new(camera.ViewportSize.X / 2, 0)
		tracer.To = Vector2.new(chestScreen.X, chestScreen.Y)
		tracer.Visible = true
	end
end

function ensureHealthBar(character)
	if not character or not character.Parent then
		if healthBars[character] then
			pcall(function()
				if healthBars[character].bg then healthBars[character].bg:Remove() end
				if healthBars[character].fill then healthBars[character].fill:Remove() end
			end)
			healthBars[character] = nil
		end
		return
	end

	-- Verificar se est√° na mesma dimens√£o
	if not isInSameDimension(character) then
		if healthBars[character] then
			pcall(function()
				if healthBars[character].bg then healthBars[character].bg:Remove() end
				if healthBars[character].fill then healthBars[character].fill:Remove() end
			end)
			healthBars[character] = nil
		end
		return
	end

	if not espEnabled or not showHealth then
		if healthBars[character] then
			pcall(function()
				if healthBars[character].bg then healthBars[character].bg:Remove() end
				if healthBars[character].fill then healthBars[character].fill:Remove() end
			end)
			healthBars[character] = nil
		end
		return
	end
	
	-- Verificar dist√¢ncia
	local myChar = LocalPlayer.Character
	if myChar then
		local myRoot = getPrimaryPart(myChar)
		local targetRoot = getPrimaryPart(character)
		if myRoot and targetRoot then
			local distance = (targetRoot.Position - myRoot.Position).Magnitude
			if distance >= ESP_MAX_DISTANCE then
				if healthBars[character] then
					pcall(function()
						if healthBars[character].bg then healthBars[character].bg:Remove() end
						if healthBars[character].fill then healthBars[character].fill:Remove() end
					end)
					healthBars[character] = nil
				end
				return
			end
		end
	end

	local head = character:FindFirstChild("Head")
	local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	local leftFoot = character:FindFirstChild("LeftFoot") or character:FindFirstChild("Left Leg")
	local rightFoot = character:FindFirstChild("RightFoot") or character:FindFirstChild("Right Leg")
	
	if not head or not humanoidRootPart or not humanoid then return end

	local camera = workspace.CurrentCamera
	
	-- Usar os mesmos pontos da box
	local topPos = head.Position + Vector3.new(0, head.Size.Y/2, 0)
	local bottomPos
	
	if leftFoot and rightFoot then
		local leftPos = leftFoot.Position - Vector3.new(0, leftFoot.Size.Y/2, 0)
		local rightPos = rightFoot.Position - Vector3.new(0, rightFoot.Size.Y/2, 0)
		bottomPos = (leftPos + rightPos) / 2
	else
		bottomPos = humanoidRootPart.Position - Vector3.new(0, 3, 0)
	end
	
	local topScreen, topOnScreen = camera:WorldToViewportPoint(topPos)
	local bottomScreen, bottomOnScreen = camera:WorldToViewportPoint(bottomPos)

	if not topOnScreen or not bottomOnScreen then
		if healthBars[character] then
			healthBars[character].bg.Visible = false
			healthBars[character].fill.Visible = false
		end
		return
	end

	if not healthBars[character] then
		local bg = Drawing.new("Square")
		bg.Thickness = 1
		bg.Filled = false
		bg.Color = Color3.fromRGB(0, 0, 0)
		bg.Transparency = 1

		local fill = Drawing.new("Square")
		fill.Thickness = 0
		fill.Filled = true
		fill.Transparency = 1

		healthBars[character] = {bg = bg, fill = fill}
	end

	local healthPercent = humanoid.Health / humanoid.MaxHealth
	local barHeight = math.abs(topScreen.Y - bottomScreen.Y)
	local barWidth = 4
	local boxWidth = barHeight * 0.4

	-- Posicionar barra √† esquerda da box
	local barX = topScreen.X - boxWidth/2 - barWidth - 6
	local barY = topScreen.Y

	healthBars[character].bg.Size = Vector2.new(barWidth, barHeight)
	healthBars[character].bg.Position = Vector2.new(barX, barY)
	healthBars[character].bg.Visible = true

	local fillHeight = barHeight * healthPercent
	healthBars[character].fill.Size = Vector2.new(barWidth - 2, fillHeight)
	healthBars[character].fill.Position = Vector2.new(barX + 1, barY + barHeight - fillHeight)

	if healthPercent > 0.5 then
		healthBars[character].fill.Color = Color3.fromRGB(0, 255, 0)
	elseif healthPercent > 0.25 then
		healthBars[character].fill.Color = Color3.fromRGB(255, 255, 0)
	else
		healthBars[character].fill.Color = Color3.fromRGB(255, 0, 0)
	end

	healthBars[character].fill.Visible = true
end

function ensureOverlayFor(p, character)
	return -- Removido - n√£o usamos mais overlays de texto
end

function overlayOffsetFor(positionName)
	if positionName == "Topo" then
		return Vector3.new(0, 2.6, 0)
	elseif positionName == "Baixo" then
		return Vector3.new(0, -2.0, 0)
	else
		return Vector3.new(2.5, 1.2, 0) -- direita
	end
end



function updateOverlay(p, character, bb)
	return -- Removido
end

function refreshESPForPlayer(p)
	if p == LocalPlayer then return end

	local char = p.Character; if not char then return end
	if espEnabled then
		ensureHighlight(char)
		ensureBox3D(char)
		if showHealth then
			ensureHealthBar(char)
		end
	else
		if highlights[char] then highlights[char].Enabled = false end
		if boxes[char] then boxes[char]:Destroy(); boxes[char] = nil end
		if healthBars[char] then
			if healthBars[char].bg then healthBars[char].bg.Visible = false end
			if healthBars[char].fill then healthBars[char].fill.Visible = false end
		end
	end
end

-- Sistema ESP Otimizado - Atualiza automaticamente ap√≥s morte
function cleanupESPForCharacter(character)
	if not character then return end

	pcall(function()
		if overlays[character] then
			overlays[character]:Destroy()
			overlays[character] = nil
		end
		if highlights[character] then
			highlights[character]:Destroy()
			highlights[character] = nil
		end
		if boxes[character] then
			for _, line in pairs(boxes[character]) do
				if line then line:Remove() end
			end
			boxes[character] = nil
		end
		if distanceLabels[character] then
			distanceLabels[character]:Remove()
			distanceLabels[character] = nil
		end
		if nameLabels[character] then
			nameLabels[character]:Remove()
			nameLabels[character] = nil
		end
		if tracers[character] then
			tracers[character]:Remove()
			tracers[character] = nil
		end
		if healthBars[character] then
			if healthBars[character].bg then healthBars[character].bg:Remove() end
			if healthBars[character].fill then healthBars[character].fill:Remove() end
			healthBars[character] = nil
		end
	end)
end

-- Inicial + eventos de players (DESABILITADO - usar sistema manual)
-- Sistema de atualiza√ß√£o autom√°tica do ESP sincronizado com lista
task.spawn(function()
	while true do
		task.wait(5) -- Atualizar a cada 5 segundos
		
		if not espEnabled then
			-- Limpar todos os ESPs se desativado
			for char, highlight in pairs(highlights) do
				if highlight then pcall(function() highlight:Destroy() end) end
			end
			for char, overlay in pairs(overlays) do
				if overlay then pcall(function() overlay:Destroy() end) end
			end
			for char, lines in pairs(boxes) do
				if lines then
					for _, line in pairs(lines) do
						if line then pcall(function() line:Remove() end) end
					end
				end
			end
			for char, tracer in pairs(tracers) do
				if tracer then pcall(function() tracer:Remove() end) end
			end
			for char, label in pairs(distanceLabels) do
				if label then pcall(function() label:Remove() end) end
			end
			for char, label in pairs(nameLabels) do
				if label then pcall(function() label:Remove() end) end
			end
			highlights = {}
			overlays = {}
			boxes = {}
			tracers = {}
			distanceLabels = {}
			nameLabels = {}
			continue
		end
		
		-- Limpar ESPs de personagens que n√£o existem mais
		for char, highlight in pairs(highlights) do
			if not char or not char.Parent then
				pcall(function() highlight:Destroy() end)
				highlights[char] = nil
			end
		end
		for char, overlay in pairs(overlays) do
			if not char or not char.Parent then
				pcall(function() overlay:Destroy() end)
				overlays[char] = nil
			end
		end
		for char, lines in pairs(boxes) do
			if not char or not char.Parent then
				for _, line in pairs(lines) do
					if line then pcall(function() line:Remove() end) end
				end
				boxes[char] = nil
			end
		end
		for char, tracer in pairs(tracers) do
			if not char or not char.Parent then
				pcall(function() tracer:Remove() end)
				tracers[char] = nil
			end
		end
		for char, label in pairs(nameLabels) do
			if not char or not char.Parent then
				pcall(function() label:Remove() end)
				nameLabels[char] = nil
			end
		end
		for char, label in pairs(distanceLabels) do
			if not char or not char.Parent then
				pcall(function() label:Remove() end)
				distanceLabels[char] = nil
			end
		end

		for char, bar in pairs(healthBars) do
			if not char or not char.Parent then
				pcall(function()
					if bar.bg then bar.bg:Remove() end
					if bar.fill then bar.fill:Remove() end
				end)
				healthBars[char] = nil
			end
		end
		
		for _, player in ipairs(Players:GetPlayers()) do
			if player and player ~= LocalPlayer and player.Character then
				refreshESPForPlayer(player)
			end
		end
	end
end)

-- Atualiza√ß√£o peri√≥dica otimizada (DESABILITADO - usar sistema manual acima)
-- O ESP agora √© atualizado no loop principal acima







-- ========= Spectate (c√¢mara) - VERS√ÉO FORNECIDA =========
function startSpectate(p)
    if not p or p == LocalPlayer then return end
    local targetChar = p.Character
    if not targetChar then return end
    local hum = targetChar:FindFirstChildOfClass("Humanoid")
    if not hum then return end

    if not savedSubject then savedSubject = Camera.CameraSubject end
    if not savedCamType then savedCamType = Camera.CameraType end

    Camera.CameraType = Enum.CameraType.Custom
    Camera.CameraSubject = hum
    spectating = p

    if spectateConn then spectateConn:Disconnect() end
    spectateConn = spectating.CharacterAdded:Connect(function(char)
        task.wait(0.1)
        local hum = char:FindFirstChildOfClass("Humanoid")
        if hum then
            Camera.CameraSubject = hum
        end
    end)
    
    -- Criar tracer line
    if not spectateTracerLine then
        spectateTracerLine = Instance.new("Part")
        spectateTracerLine.Name = "SpectateTracer"
        spectateTracerLine.Anchored = true
        spectateTracerLine.CanCollide = false
        spectateTracerLine.Material = Enum.Material.Neon
        spectateTracerLine.Color = Color3.fromRGB(0, 255, 255)
        spectateTracerLine.Size = Vector3.new(0.1, 0.1, 1)
        spectateTracerLine.Parent = workspace
    end
end

function stopSpectate()
    if savedSubject then Camera.CameraSubject = savedSubject end
    if savedCamType then Camera.CameraType = savedCamType end
    spectating = nil
    if spectateConn then spectateConn:Disconnect() spectateConn = nil end
    
    -- Remover tracer line
    if spectateTracerLine then
        spectateTracerLine:Destroy()
        spectateTracerLine = nil
    end
end

-- ========= Instant TP to Player =========
function instantTPTo(targetPlayer)
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	local char = LocalPlayer.Character
	local targetChar = targetPlayer.Character
	if not char or not targetChar then return end
	local srcPart = getPrimaryPart(char)
	local dstPart = getPrimaryPart(targetChar)
	if not srcPart or not dstPart then return end
	local offset = Vector3.new(0,3,0)
	char:PivotTo(CFrame.new(dstPart.Position + offset, dstPart.Position + offset + dstPart.CFrame.LookVector))
end





-- Se o espectado respawnar, mant√©m
Players.PlayerAdded:Connect(function(p)
	if p == spectating then
		p.CharacterAdded:Connect(function(char)
			task.wait(0.1)
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum and spectating == p then
				Camera.CameraSubject = hum
			end
		end)
	end
end)

-- Sistema de verifica√ß√£o cont√≠nua do spectate
RunService.RenderStepped:Connect(function()
	if spectating and spectating.Parent then
		local targetChar = spectating.Character
		if not targetChar then
			stopSpectate()
			return
		end

		-- Garantir que a c√¢mera ainda est√° no modo correto
		local hum = targetChar:FindFirstChildOfClass("Humanoid")
		if Camera.CameraType ~= Enum.CameraType.Custom or Camera.CameraSubject ~= hum then
			Camera.CameraType = Enum.CameraType.Custom
			if hum then Camera.CameraSubject = hum end
		end
		
		-- Atualizar tracer line
		if spectateTracerLine then
			local myChar = LocalPlayer.Character
			if myChar then
				local myRoot = myChar:FindFirstChild("HumanoidRootPart")
				local targetRoot = targetChar:FindFirstChild("HumanoidRootPart")
				if myRoot and targetRoot then
					local startPos = targetRoot.Position
					local endPos = myRoot.Position
					local distance = (endPos - startPos).Magnitude
					local midPoint = (startPos + endPos) / 2
					
					spectateTracerLine.Size = Vector3.new(0.1, 0.1, distance)
					spectateTracerLine.CFrame = CFrame.new(midPoint, endPos)
					spectateTracerLine.Transparency = 0.3
				else
					spectateTracerLine.Transparency = 1
				end
			else
				spectateTracerLine.Transparency = 1
			end
		end
	else
		-- Jogador saiu do jogo
		if spectating then
			stopSpectate()
		end
	end
end)

-- ========= SAKURA MENU - Japanese Style =========
local SAKURA = {
    primary = Color3.fromRGB(255, 105, 180),
    secondary = Color3.fromRGB(255, 182, 193),
    accent = Color3.fromRGB(138, 43, 226),
    success = Color3.fromRGB(50, 205, 50),
    danger = Color3.fromRGB(220, 20, 60),
    background = Color3.fromRGB(15, 15, 25),
    surface = Color3.fromRGB(25, 25, 40),
    surfaceLight = Color3.fromRGB(40, 40, 60),
    border = Color3.fromRGB(255, 105, 180),
    text = Color3.fromRGB(255, 255, 255),
    textMuted = Color3.fromRGB(180, 180, 200),
    gold = Color3.fromRGB(255, 215, 0),
    shadow = Color3.fromRGB(0, 0, 0)
}

-- Compatibility colors
local COLOR_SLIDER_TRACK = SAKURA.background
local COLOR_NEON_PINK = SAKURA.primary
local COLOR_BG_MAIN = SAKURA.background
local COLOR_BG_PANEL = SAKURA.surface
local COLOR_TEXT_PRIMARY = SAKURA.text
local COLOR_TOGGLE_OFF_BG = Color3.fromRGB(200, 200, 200)
local COLOR_TOGGLE_OFF_CIRCLE = Color3.fromRGB(150, 150, 150)

local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local gui = Instance.new("ScreenGui")
gui.Name = "SakuraMenuJapanese"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.DisplayOrder = 999999999
gui.Parent = playerGui





-- Main Sakura Frame
mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 1000, 0, 750)
mainFrame.Position = UDim2.new(0.5, -500, 0.5, -375)
mainFrame.BackgroundColor3 = SAKURA.background
mainFrame.Visible = true -- ABRIR DIRETO
mainFrame.BorderSizePixel = 0
mainFrame.ZIndex = 10000001
mainFrame.Parent = gui

-- Sistema de p√©talas caindo
local petalsContainer = Instance.new("Frame")
petalsContainer.Size = UDim2.new(1, 0, 1, 0)
petalsContainer.BackgroundTransparency = 1
petalsContainer.ZIndex = 10000000
petalsContainer.Parent = mainFrame

task.spawn(function()
    while true do
        task.wait(0.3)
        if mainFrame.Visible then
            local petal = Instance.new("Frame")
            petal.Size = UDim2.new(0, math.random(10, 20), 0, math.random(10, 20))
            petal.Position = UDim2.new(math.random(), 0, 0, -30)
            petal.BackgroundColor3 = Color3.fromRGB(255, math.random(100, 180), math.random(150, 220))
            petal.BackgroundTransparency = 0.2
            petal.BorderSizePixel = 0
            petal.Rotation = math.random(0, 360)
            petal.ZIndex = 10000000
            petal.Parent = petalsContainer
            
            local corner = Instance.new("UICorner")
            corner.CornerRadius = UDim.new(1, 0)
            corner.Parent = petal
            
            local fallTime = math.random(4, 8)
            local endX = math.random(-80, 80)
            
            TweenService:Create(petal, TweenInfo.new(fallTime, Enum.EasingStyle.Sine), {
                Position = UDim2.new(petal.Position.X.Scale, endX, 1, 50),
                Rotation = petal.Rotation + math.random(360, 720),
                BackgroundTransparency = 1
            }):Play()
            
            task.delay(fallTime, function()
                petal:Destroy()
            end)
        end
    end
end)

local mainCorner = Instance.new("UICorner")
mainCorner.CornerRadius = UDim.new(0, 15)
mainCorner.Parent = mainFrame

local mainBorder = Instance.new("UIStroke")
mainBorder.Color = SAKURA.border
mainBorder.Thickness = 3
mainBorder.Parent = mainFrame

-- Sakura Header
local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 90)
header.BackgroundColor3 = SAKURA.surface
header.BorderSizePixel = 0
header.Parent = mainFrame

local headerCorner = Instance.new("UICorner")
headerCorner.CornerRadius = UDim.new(0, 15)
headerCorner.Parent = header

local headerBorder = Instance.new("UIStroke")
headerBorder.Color = SAKURA.border
headerBorder.Thickness = 2
headerBorder.Parent = header

local title = Instance.new("TextLabel")
title.Name = "Title"
title.Size = UDim2.new(1, -120, 1, 0)
title.Position = UDim2.new(0, 30, 0, 0)
title.BackgroundTransparency = 1
title.Text = "SAKURA // MOD MENU"
title.Font = Enum.Font.GothamBold
title.TextSize = 20
title.TextColor3 = SAKURA.text
title.TextXAlignment = Enum.TextXAlignment.Left
title.Parent = header

local subtitle = Instance.new("TextLabel")
subtitle.Size = UDim2.new(1, -120, 0, 20)
subtitle.Position = UDim2.new(0, 30, 0, 50)
subtitle.BackgroundTransparency = 1
subtitle.Text = "v1.0 | Premium Edition"
subtitle.Font = Enum.Font.Gotham
subtitle.TextSize = 11
subtitle.TextColor3 = SAKURA.textMuted
subtitle.TextXAlignment = Enum.TextXAlignment.Left
subtitle.Parent = header

local closeBtn = Instance.new("TextButton")
closeBtn.Parent = header
closeBtn.BackgroundColor3 = SAKURA.danger
closeBtn.Position = UDim2.new(1, -60, 0.5, -20)
closeBtn.Size = UDim2.new(0, 40, 0, 40)
closeBtn.Font = Enum.Font.GothamBold
closeBtn.Text = "√ó"
closeBtn.TextColor3 = SAKURA.surface
closeBtn.TextSize = 20
closeBtn.BorderSizePixel = 0

local closeBtnCorner = Instance.new("UICorner")
closeBtnCorner.Parent = closeBtn
closeBtnCorner.CornerRadius = UDim.new(0, 8)

closeBtn.MouseButton1Click:Connect(function()
	showPanel(false)
end)



-- Sidebar
local sidebar = Instance.new("Frame")
sidebar.Name = "Sidebar"
sidebar.Size = UDim2.new(0, 280, 1, -90)
sidebar.Position = UDim2.new(0, 0, 0, 90)
sidebar.BackgroundColor3 = SAKURA.surface
sidebar.BorderSizePixel = 0
sidebar.Parent = mainFrame

local sidebarBorder = Instance.new("UIStroke")
sidebarBorder.Color = SAKURA.border
sidebarBorder.Thickness = 2
sidebarBorder.Parent = sidebar

local sidebarLayout = Instance.new("UIListLayout")
sidebarLayout.SortOrder = Enum.SortOrder.LayoutOrder
sidebarLayout.Padding = UDim.new(0, 12)
sidebarLayout.HorizontalAlignment = Enum.HorizontalAlignment.Center
sidebarLayout.Parent = sidebar

local sidebarPadding = Instance.new("UIPadding")
sidebarPadding.PaddingTop = UDim.new(0, 20)
sidebarPadding.Parent = sidebar

-- Content Panel
local content = Instance.new("ScrollingFrame")
content.Name = "Content"
content.Size = UDim2.new(1, -290, 1, -100)
content.Position = UDim2.new(0, 285, 0, 95)
content.BackgroundTransparency = 1
content.ScrollBarThickness = 10
content.ScrollBarImageColor3 = SAKURA.primary
content.CanvasSize = UDim2.new(0, 0, 0, 2000)
content.BorderSizePixel = 0
content.Parent = mainFrame

local contentLayout = Instance.new("UIListLayout")
contentLayout.Padding = UDim.new(0, 15)
contentLayout.SortOrder = Enum.SortOrder.LayoutOrder
contentLayout.Parent = content

local contentPadding = Instance.new("UIPadding")
contentPadding.PaddingTop = UDim.new(0, 20)
contentPadding.PaddingLeft = UDim.new(0, 20)
contentPadding.PaddingRight = UDim.new(0, 20)
contentPadding.Parent = content



-- Pages
pages = {}
tabs = {}
currentTab = "PLAYERS"

function createPage(name)
	local page = Instance.new("ScrollingFrame")
	page.Size = UDim2.new(1, 0, 1, 0)
	page.BackgroundTransparency = 1
	page.Visible = false
	page.ScrollBarThickness = 4
	page.ScrollBarImageColor3 = SAKURA.primary
	page.BorderSizePixel = 0
	page.CanvasSize = UDim2.new(0, 0, 0, 0)
	page.AutomaticCanvasSize = Enum.AutomaticSize.Y
	page.Parent = content
	
	local layout = Instance.new("UIListLayout")
	layout.Padding = UDim.new(0, 12)
	layout.HorizontalAlignment = Enum.HorizontalAlignment.Center
	layout.Parent = page
	
	local padding = Instance.new("UIPadding")
	padding.PaddingTop = UDim.new(0, 12)
	padding.PaddingBottom = UDim.new(0, 12)
	padding.Parent = page
	
	pages[name] = page
	return page
end

function createTab(name, text, icon, order)
	local tab = Instance.new("TextButton")
	tab.Name = name .. "Tab"
	tab.Size = UDim2.new(1, -20, 0, 48)
	tab.BackgroundColor3 = SAKURA.surface
	tab.Text = ""
	tab.BorderSizePixel = 0
	tab.LayoutOrder = order
	tab.Parent = sidebar
	
	local tabCorner = Instance.new("UICorner")
	tabCorner.CornerRadius = UDim.new(0, 6)
	tabCorner.Parent = tab
	
	local tabBorder = Instance.new("UIStroke")
	tabBorder.Color = SAKURA.border
	tabBorder.Thickness = 1
	tabBorder.Transparency = 0.8
	tabBorder.Parent = tab
	
	local tabIcon = Instance.new("TextLabel")
	tabIcon.Size = UDim2.new(0, 25, 1, 0)
	tabIcon.Position = UDim2.new(0, 12, 0, 0)
	tabIcon.BackgroundTransparency = 1
	tabIcon.Text = icon
	tabIcon.Font = Enum.Font.GothamBold
	tabIcon.TextSize = 16
	tabIcon.TextColor3 = SAKURA.textMuted
	tabIcon.TextXAlignment = Enum.TextXAlignment.Center
	tabIcon.Parent = tab
	
	local tabLabel = Instance.new("TextLabel")
	tabLabel.Size = UDim2.new(1, -50, 1, 0)
	tabLabel.Position = UDim2.new(0, 42, 0, 0)
	tabLabel.BackgroundTransparency = 1
	tabLabel.Text = text:upper()
	tabLabel.Font = Enum.Font.GothamBold
	tabLabel.TextSize = 12
	tabLabel.TextColor3 = SAKURA.textMuted
	tabLabel.TextXAlignment = Enum.TextXAlignment.Left
	tabLabel.Parent = tab
	
	tab.MouseEnter:Connect(function()
		if currentTab ~= name then
			TweenService:Create(tab, TweenInfo.new(0.2), {BackgroundColor3 = SAKURA.surfaceLight}):Play()
		end
	end)
	
	tab.MouseLeave:Connect(function()
		if currentTab ~= name then
			TweenService:Create(tab, TweenInfo.new(0.2), {BackgroundColor3 = SAKURA.surface}):Play()
		end
	end)
	
	tab.MouseButton1Click:Connect(function()
		setTab(name)
	end)
	
	tabs[name] = {tab, tabIcon, tabLabel, tabBorder}
	return tab
end

function setTab(tabName)
	for name, tabData in pairs(tabs) do
		local tab, icon, label, border = tabData[1], tabData[2], tabData[3], tabData[4]
		if name == tabName then
			TweenService:Create(tab, TweenInfo.new(0.3), {BackgroundColor3 = SAKURA.surfaceLight}):Play()
			TweenService:Create(icon, TweenInfo.new(0.3), {TextColor3 = SAKURA.primary}):Play()
			TweenService:Create(label, TweenInfo.new(0.3), {TextColor3 = SAKURA.primary}):Play()
			TweenService:Create(border, TweenInfo.new(0.3), {Transparency = 0.3, Color = SAKURA.primary}):Play()
			pages[name].Visible = true
			currentTab = name
		else
			TweenService:Create(tab, TweenInfo.new(0.3), {BackgroundColor3 = SAKURA.surface}):Play()
			TweenService:Create(icon, TweenInfo.new(0.3), {TextColor3 = SAKURA.textMuted}):Play()
			TweenService:Create(label, TweenInfo.new(0.3), {TextColor3 = SAKURA.textMuted}):Play()
			TweenService:Create(border, TweenInfo.new(0.3), {Transparency = 0.8, Color = SAKURA.border}):Play()
			pages[name].Visible = false
		end
	end
end

local playersPage = createPage("PLAYERS")
local espPage = createPage("ESP")
local aimbotPage = createPage("AIMBOT")
local utilPage = createPage("UTIL")
local configPage = createPage("CONFIG")

local tabPlayers = createTab("PLAYERS", "Players", "üë•", 1)
local tabESP = createTab("ESP", "ESP", "üëÅÔ∏è", 2)
local tabAimbot = createTab("AIMBOT", "RAGE", "üéØ", 3)
local tabUtil = createTab("UTIL", "Misc", "‚öôÔ∏è", 4)
local tabConfig = createTab("CONFIG", "Config", "üíæ", 5)

setTab("PLAYERS")

-- Make draggable
local dragging = false
local dragStart = nil
local startPos = nil

header.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = mainFrame.Position
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)



function createCategory(parent, title)
	local category = Instance.new("Frame")
	category.Size = UDim2.new(0.98, 0, 0, 0)
	category.BackgroundColor3 = SAKURA.surface
	category.BackgroundTransparency = 0
	category.BorderSizePixel = 0
	category.Parent = parent

	local categoryCorner = Instance.new("UICorner")
	categoryCorner.CornerRadius = UDim.new(0, 8)
	categoryCorner.Parent = category

	local categoryBorder = Instance.new("UIStroke")
	categoryBorder.Color = SAKURA.border
	categoryBorder.Thickness = 1
	categoryBorder.Transparency = 0.7
	categoryBorder.Parent = category

	local titleBar = Instance.new("Frame")
	titleBar.Size = UDim2.new(1, 0, 0, 32)
	titleBar.BackgroundColor3 = SAKURA.surfaceLight
	titleBar.BorderSizePixel = 0
	titleBar.Parent = category
	
	local titleCorner = Instance.new("UICorner")
	titleCorner.CornerRadius = UDim.new(0, 8)
	titleCorner.Parent = titleBar
	
	local titleFix = Instance.new("Frame")
	titleFix.Size = UDim2.new(1, 0, 0, 8)
	titleFix.Position = UDim2.new(0, 0, 1, -8)
	titleFix.BackgroundColor3 = SAKURA.surfaceLight
	titleFix.BorderSizePixel = 0
	titleFix.Parent = titleBar

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -20, 1, 0)
	titleLabel.Position = UDim2.new(0, 10, 0, 0)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = "// " .. title:upper()
	titleLabel.Font = Enum.Font.GothamBold
	titleLabel.TextSize = 13
	titleLabel.TextColor3 = SAKURA.text
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = titleBar

	local contentFrame = Instance.new("Frame")
	contentFrame.Size = UDim2.new(1, -20, 1, -42)
	contentFrame.Position = UDim2.new(0, 10, 0, 37)
	contentFrame.BackgroundTransparency = 1
	contentFrame.ClipsDescendants = true
	contentFrame.Parent = category

	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Padding = UDim.new(0, 6)
	contentLayout.Parent = contentFrame

	local function updateSize()
		local contentSize = contentLayout.AbsoluteContentSize
		local newHeight = contentSize.Y + 48
		category.Size = UDim2.new(0.98, 0, 0, newHeight)
	end

	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSize)

	return contentFrame
end

function createToggle(parent, text, callback)
	local container = Instance.new("Frame")
	container.Parent = parent
	container.BackgroundColor3 = SAKURA.surfaceLight
	container.Size = UDim2.new(1, -10, 0, 40)
	container.BorderSizePixel = 0
	
	local corner = Instance.new("UICorner")
	corner.Parent = container
	corner.CornerRadius = UDim.new(0, 6)
	
	local border = Instance.new("UIStroke")
	border.Parent = container
	border.Color = SAKURA.border
	border.Thickness = 1
	border.Transparency = 0.8
	
	local glow = Instance.new("UIStroke")
	glow.Parent = container
	glow.Color = SAKURA.primary
	glow.Thickness = 0
	glow.Transparency = 0.5
	glow.ApplyStrokeMode = Enum.ApplyStrokeMode.Border
	
	local label = Instance.new("TextLabel")
	label.Parent = container
	label.BackgroundTransparency = 1
	label.Position = UDim2.new(0, 10, 0, 0)
	label.Size = UDim2.new(0.65, 0, 1, 0)
	label.Font = Enum.Font.GothamBold
	label.Text = text
	label.TextColor3 = SAKURA.text
	label.TextSize = 12
	label.TextXAlignment = Enum.TextXAlignment.Left
	
	local switchBg = Instance.new("Frame")
	switchBg.Parent = container
	switchBg.BackgroundColor3 = Color3.fromRGB(40, 40, 45)
	switchBg.Position = UDim2.new(1, -45, 0.5, -9)
	switchBg.Size = UDim2.new(0, 38, 0, 18)
	switchBg.BorderSizePixel = 0
	
	local switchCorner = Instance.new("UICorner")
	switchCorner.Parent = switchBg
	switchCorner.CornerRadius = UDim.new(1, 0)
	
	local switchBtn = Instance.new("Frame")
	switchBtn.Parent = switchBg
	switchBtn.BackgroundColor3 = Color3.fromRGB(80, 80, 85)
	switchBtn.Position = UDim2.new(0, 2, 0, 2)
	switchBtn.Size = UDim2.new(0, 14, 0, 14)
	switchBtn.BorderSizePixel = 0
	
	local btnCorner = Instance.new("UICorner")
	btnCorner.Parent = switchBtn
	btnCorner.CornerRadius = UDim.new(1, 0)
	
	local btnGlow = Instance.new("UIStroke")
	btnGlow.Parent = switchBtn
	btnGlow.Color = SAKURA.primary
	btnGlow.Thickness = 0
	btnGlow.Transparency = 0
	
	local enabled = false
	
	local clickArea = Instance.new("TextButton")
	clickArea.Parent = container
	clickArea.BackgroundTransparency = 1
	clickArea.Size = UDim2.new(1, 0, 1, 0)
	clickArea.Text = ""
	
	clickArea.MouseEnter:Connect(function()
		TweenService:Create(glow, TweenInfo.new(0.2), {Thickness = 2}):Play()
		TweenService:Create(container, TweenInfo.new(0.2), {BackgroundColor3 = Color3.fromRGB(40, 40, 50)}):Play()
	end)
	
	clickArea.MouseLeave:Connect(function()
		TweenService:Create(glow, TweenInfo.new(0.2), {Thickness = 0}):Play()
		TweenService:Create(container, TweenInfo.new(0.2), {BackgroundColor3 = SAKURA.surfaceLight}):Play()
	end)
	
	clickArea.MouseButton1Click:Connect(function()
		enabled = not enabled
		local targetPos = enabled and UDim2.new(1, -16, 0, 2) or UDim2.new(0, 2, 0, 2)
		local targetBgColor = enabled and SAKURA.primary or Color3.fromRGB(40, 40, 45)
		local targetBtnColor = enabled and Color3.fromRGB(255, 255, 255) or Color3.fromRGB(80, 80, 85)
		local targetGlow = enabled and 3 or 0
		
		TweenService:Create(switchBtn, TweenInfo.new(0.3, Enum.EasingStyle.Back), {
			Position = targetPos,
			BackgroundColor3 = targetBtnColor
		}):Play()
		
		TweenService:Create(switchBg, TweenInfo.new(0.3, Enum.EasingStyle.Quad), {
			BackgroundColor3 = targetBgColor
		}):Play()
		
		TweenService:Create(btnGlow, TweenInfo.new(0.3), {Thickness = targetGlow}):Play()
		
		if callback then callback(enabled) end
	end)
	
	return container
end

-- üîß VERS√ÉO MELHORADA: Players Page com melhorias visuais e sistema de toggles
local playerButtons = {}
local playersCategory = createCategory(playersPage, "Lista de Jogadores")

-- Container para pesquisa e contador
local topContainer = Instance.new("Frame")
topContainer.Size = UDim2.new(1, 0, 0, 40)
topContainer.BackgroundTransparency = 1
topContainer.Parent = playersCategory

-- Campo de pesquisa (lado esquerdo)
local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(0.7, -5, 1, 0)
searchBox.Position = UDim2.new(0, 0, 0, 0)
searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchBox.PlaceholderText = ""
searchBox.Text = ""
searchBox.Font = Enum.Font.SourceSans
searchBox.TextSize = 14
searchBox.ClearTextOnFocus = false
searchBox.Parent = topContainer
Instance.new("UICorner", searchBox).CornerRadius = UDim.new(0, 8)

-- Adicionar borda ao searchBox
local searchBoxStroke = Instance.new("UIStroke")
searchBoxStroke.Color = COLOR_NEON_PINK
searchBoxStroke.Thickness = 1
searchBoxStroke.Transparency = 0.7
searchBoxStroke.Parent = searchBox

-- Conectar pesquisa em tempo real
searchBox.Focused:Connect(function()
	isTypingInSearch = true
end)

searchBox.FocusLost:Connect(function()
	isTypingInSearch = false
end)

searchBox:GetPropertyChangedSignal("Text"):Connect(function()
	local text = searchBox.Text:lower()
	for player, button in pairs(playerButtons) do
		if button and button.Parent then
			local playerName = player.Name:lower()
			local displayName = (player.DisplayName or ""):lower()
			local matches = playerName:find(text, 1, true) or displayName:find(text, 1, true)
			button.Visible = (text == "" or matches ~= nil)
		end
	end
end)

-- Contador de jogadores (lado direito)
local playerCounter = Instance.new("TextLabel")
playerCounter.Size = UDim2.new(0.3, -5, 1, 0)
playerCounter.Position = UDim2.new(0.7, 5, 0, 0)
playerCounter.BackgroundColor3 = Color3.fromRGB(30, 30, 40)
playerCounter.TextColor3 = Color3.fromRGB(200, 200, 255)
playerCounter.Font = Enum.Font.SourceSansBold
playerCounter.TextSize = 14
playerCounter.Text = "0 jogadores"
playerCounter.Parent = topContainer
Instance.new("UICorner", playerCounter).CornerRadius = UDim.new(0, 8)

-- Container para lista e a√ß√µes - MAIOR
local playersContainer = Instance.new("Frame")
playersContainer.Size = UDim2.new(1, 0, 0, 550)
playersContainer.BackgroundTransparency = 1
playersContainer.Parent = playersCategory

-- Lista de jogadores - 55% da largura
local playersList = Instance.new("ScrollingFrame")
playersList.Size = UDim2.new(0.55, -5, 1, 0)
playersList.Position = UDim2.new(0, 0, 0, 0)
playersList.BackgroundColor3 = Color3.fromRGB(32, 32, 38)
playersList.BorderSizePixel = 0
playersList.ScrollBarThickness = 6
playersList.Parent = playersContainer
Instance.new("UICorner", playersList).CornerRadius = UDim.new(0, 8)

local playersLayout = Instance.new("UIListLayout")
playersLayout.Padding = UDim.new(0, 4)
playersLayout.Parent = playersList

playersList.AutomaticCanvasSize = Enum.AutomaticSize.Y

-- Painel de a√ß√µes - 43% da largura
local actionsPanel = Instance.new("Frame")
actionsPanel.Size = UDim2.new(0.43, -5, 1, 0)
actionsPanel.Position = UDim2.new(0.57, 5, 0, 0)
actionsPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 70)
actionsPanel.BackgroundTransparency = 0.4
actionsPanel.Parent = playersContainer
Instance.new("UICorner", actionsPanel).CornerRadius = UDim.new(0, 12)

local actionsTitle = Instance.new("TextLabel")
actionsTitle.Size = UDim2.new(1, -20, 0, 30)
actionsTitle.Position = UDim2.new(0, 10, 0, 10)
actionsTitle.BackgroundTransparency = 1
actionsTitle.Text = "A√á√ïES DO JOGADOR"
actionsTitle.Font = Enum.Font.SourceSansBold
actionsTitle.TextSize = 14
actionsTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
actionsTitle.TextXAlignment = Enum.TextXAlignment.Left
actionsTitle.Parent = actionsPanel

local actionsContainer = Instance.new("Frame")
actionsContainer.Size = UDim2.new(1, -20, 1, -50)
actionsContainer.Position = UDim2.new(0, 10, 0, 40)
actionsContainer.BackgroundTransparency = 1
actionsContainer.Parent = actionsPanel

local actionsLayout = Instance.new("UIListLayout")
actionsLayout.Padding = UDim.new(0, 8)
actionsLayout.Parent = actionsContainer

-- Estados dos toggles
spectateActive = false

-- Fun√ß√£o para criar toggle com checkbox tradicional
function createActionToggle(text, callback)
	local toggleFrame = Instance.new("Frame")
	toggleFrame.Size = UDim2.new(1, 0, 0, 40)
	toggleFrame.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	toggleFrame.BackgroundTransparency = 0.2
	toggleFrame.Parent = actionsContainer
	Instance.new("UICorner", toggleFrame).CornerRadius = UDim.new(0, 8)

	-- Checkbox quadrado
	local checkbox = Instance.new("TextButton")
	checkbox.Size = UDim2.new(0, 20, 0, 20)
	checkbox.Position = UDim2.new(0, 10, 0.5, -10)
	checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 90) -- Fundo do checkbox
	checkbox.Text = "" -- Sem texto inicialmente
	checkbox.Font = Enum.Font.SourceSansBold
	checkbox.TextSize = 16
	checkbox.TextColor3 = Color3.fromRGB(255, 255, 255)
	checkbox.Parent = toggleFrame
	Instance.new("UICorner", checkbox).CornerRadius = UDim.new(0, 4)

	-- Label do texto
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -40, 1, 0)
	label.Position = UDim2.new(0, 40, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.Font = Enum.Font.SourceSansBold
	label.TextSize = 14
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = toggleFrame

	local enabled = false

	checkbox.MouseButton1Click:Connect(function()
		if not selectedPlayer then
			return
		end

		enabled = not enabled

		if enabled then
			-- Checkbox marcado
			checkbox.Text = "‚úì"
			checkbox.BackgroundColor3 = Color3.fromRGB(0, 150, 0) -- Verde
		else
			-- Checkbox desmarcado
			checkbox.Text = ""
			checkbox.BackgroundColor3 = Color3.fromRGB(80, 80, 90) -- Cinza
		end

		if callback then
			callback(enabled)
		end
	end)

	-- Esconder inicialmente
	toggleFrame.Visible = false

	return toggleFrame
end

-- Bot√£o de teleporte (a√ß√£o √∫nica, n√£o toggle)
local tpBtn = Instance.new("TextButton")
tpBtn.Size = UDim2.new(1, 0, 0, 40)
tpBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
tpBtn.BackgroundTransparency = 0.2
tpBtn.Text = "üìç TELEPORTAR"
tpBtn.Font = Enum.Font.SourceSansBold
tpBtn.TextSize = 14
tpBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
tpBtn.Parent = actionsContainer
Instance.new("UICorner", tpBtn).CornerRadius = UDim.new(0, 8)

-- Toggles para a√ß√µes
local spectateToggle = createActionToggle("üëÅÔ∏è ESPECTAR", function(enabled)
	spectateActive = enabled
	if enabled and selectedPlayer then
		startSpectate(selectedPlayer)
	else
		stopSpectate()
	end
end)

-- Bot√£o Kill Player
local killBtn = Instance.new("TextButton")
killBtn.Size = UDim2.new(1, 0, 0, 40)
killBtn.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
killBtn.BackgroundTransparency = 0.2
killBtn.Text = "üó°Ô∏è MATAR JOGADOR"
killBtn.Font = Enum.Font.SourceSansBold
killBtn.TextSize = 14
killBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
killBtn.Parent = actionsContainer
Instance.new("UICorner", killBtn).CornerRadius = UDim.new(0, 8)

killBtn.MouseButton1Click:Connect(function()
	if selectedPlayer then
		killPlayer(selectedPlayer)
	end
end)



-- Esconder a√ß√µes inicialmente
tpBtn.Visible = false
spectateToggle.Visible = false
killBtn.Visible = false

-- Fun√ß√£o simples para criar bot√£o de jogador
function createPlayerButton(player)
	if not player or player == LocalPlayer then return end
	if not playersList or not playersList.Parent then return end
	
	-- Verificar se j√° existe bot√£o para este jogador
	if playerButtons[player] then
		return playerButtons[player]
	end
	
	-- Remover bot√£o antigo se existir (por nome)
	local existingBtn = playersList:FindFirstChild(player.Name .. "_Simple")
	if existingBtn then
		existingBtn:Destroy()
	end

	local btn = Instance.new("TextButton")
	btn.Name = player.Name .. "_Simple"
	btn.Size = UDim2.new(1, -8, 0, 40) -- MENOR
	btn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
	btn.Text = ""
	btn.Parent = playersList
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

	local avatar = Instance.new("ImageLabel")
	avatar.Size = UDim2.new(0, 32, 0, 32) -- MENOR
	avatar.Position = UDim2.new(0, 4, 0, 4)
	avatar.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
	avatar.BorderSizePixel = 0
	avatar.Image = Players:GetUserThumbnailAsync(player.UserId, Enum.ThumbnailType.HeadShot, Enum.ThumbnailSize.Size150x150)
	avatar.Parent = btn
	Instance.new("UICorner", avatar).CornerRadius = UDim.new(1, 0)

	local nameLabel = Instance.new("TextLabel")
	nameLabel.Name = "NameLabel"
	nameLabel.Size = UDim2.new(1, -45, 1, 0)
	nameLabel.Position = UDim2.new(0, 40, 0, 0)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextSize = 12 -- MENOR
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = player.DisplayName .. " (@" .. player.Name .. ")"
	nameLabel.Parent = btn

	btn.MouseButton1Click:Connect(function()
		for _, button in pairs(playerButtons) do
			if button:IsA("TextButton") and button ~= btn then
				local label = button:FindFirstChild("NameLabel")
				if label then label.TextColor3 = Color3.fromRGB(255, 255, 255) end
			end
		end
		nameLabel.TextColor3 = Color3.fromRGB(255, 255, 0)
		selectedPlayer = player
		if tpBtn then tpBtn.Visible = true end
		if spectateToggle then spectateToggle.Visible = true end
		if spectateActive then
			spectateActive = false
			stopSpectate()
		end
	end)

	playerButtons[player] = btn
	return btn
end

-- Fun√ß√£o simples para atualizar lista - ALIAS para rebuildPlayersList
function updatePlayersList()
	if isTypingInSearch then return end
	rebuildPlayersList()
end



-- Conectar bot√µes de a√ß√£o
if tpBtn then
	tpBtn.MouseButton1Click:Connect(function()
		if selectedPlayer then
			instantTPTo(selectedPlayer)
		end
	end)
end

-- Os toggles j√° t√™m suas pr√≥prias fun√ß√µes de callback
-- N√£o precisamos de conex√µes adicionais

-- Fun√ß√£o para atualizar contador de jogadores
function updatePlayerCounter()
	local playerCount = 0
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer then
			playerCount = playerCount + 1
		end
	end
	if playerCounter then
		playerCounter.Text = playerCount .. " jogadores"
	end
end

-- Inicializar lista simples
task.spawn(function()
	task.wait(1) -- Aguardar UI carregar
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			pcall(function()
				createPlayerButton(plr)
			end)
		end
	end
	updatePlayerCounter()
end)

-- Atualizar contador quando players entram/saem
Players.PlayerAdded:Connect(function(player)
	if isTypingInSearch then return end
	if player ~= LocalPlayer then
		updatePlayerCounter()
		-- Tamb√©m atualizar lista visual
		task.wait(0.1)
		if rebuildPlayersList and not isTypingInSearch then pcall(rebuildPlayersList) end
	end
end)

Players.PlayerRemoving:Connect(function(player)
	if isTypingInSearch then return end
	if player ~= LocalPlayer then
		updatePlayerCounter()
		if rebuildPlayersList and not isTypingInSearch then rebuildPlayersList() end
	end
end)



-- Config Page - Sistema de Salvar/Carregar com Biblioteca
local configCategory = createCategory(configPage, "üíæ Gerenciar Configura√ß√µes")

-- Armazenamento de configs
local savedConfigs = {}

-- Fun√ß√£o para salvar config
function saveConfig(configName)
	local config = {
		name = configName,
		date = os.date("%d/%m/%Y %H:%M"),
		-- ESP
		espEnabled = espEnabled,
		showName = showName,
		showHealth = showHealth,
		espMode = espMode,
		espAutoEnabled = espAutoEnabled,
		showSkeleton = showSkeleton,
		showBox3D = showBox3D,
		showTracers = showTracers,
		showEspDistance = showEspDistance,
		ESP_MAX_DISTANCE = ESP_MAX_DISTANCE,
		espPosition = espPosition,
		-- Aimbot
		aimbotEnabled = aimbotEnabled,
		aimbotFOV = aimbotFOV,
		aimbotSmooth = aimbotSmooth,
		aimbotTarget = aimbotTarget,
		aimbotBindString = aimbotBindString,
		aimbotMobile = aimbotMobile,
		aimbotOnlyVisible = aimbotOnlyVisible,
		-- Misc
		speedBoostEnabled = speedBoostEnabled,
		speedBoostValue = speedBoostValue,
		jumpPowerBoostEnabled = jumpPowerBoostEnabled,
		jumpPowerBoostValue = jumpPowerBoostValue,
		infiniteJumpEnabled = infiniteJumpEnabled,
		noclip = noclip,
		FlySpeed = FlySystem.speed
	}
	
	local encoded = HttpService:JSONEncode(config)
	writefile("NightMenu_" .. configName .. ".json", encoded)
	savedConfigs[configName] = config
	return true
end

-- Fun√ß√£o para for√ßar atualiza√ß√£o visual de todos os toggles
function forceUpdateAllToggles()
	-- Simplified - just refresh ESP
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer then
			refreshESPForPlayer(p)
		end
	end
end

-- Fun√ß√£o para carregar config
function loadConfig(configName)
	local success, result = pcall(function()
		local encoded = readfile("NightMenu_" .. configName .. ".json")
		return HttpService:JSONDecode(encoded)
	end)

	if success and result then
		-- Aplicar configura√ß√µes
		espEnabled = result.espEnabled or false
		showName = result.showName or false
		showHealth = result.showHealth or false
		espMode = result.espMode or "Cheio"
		espAutoEnabled = result.espAutoEnabled or false
		showSkeleton = result.showSkeleton or false
		showBox3D = result.showBox3D or false
		showTracers = result.showTracers or false
		showEspDistance = result.showEspDistance or false
		ESP_MAX_DISTANCE = result.ESP_MAX_DISTANCE or 500
		espPosition = result.espPosition or "Topo"
		aimbotEnabled = result.aimbotEnabled or false
		aimbotFOV = result.aimbotFOV or 100
		aimbotSmooth = result.aimbotSmooth or 5
		aimbotTarget = result.aimbotTarget or "Cabe√ßa"
		aimbotBindString = result.aimbotBindString or "Nenhuma"
		aimbotMobile = result.aimbotMobile or false
		aimbotOnlyVisible = result.aimbotOnlyVisible or false
		speedBoostEnabled = result.speedBoostEnabled or false
		speedBoostValue = result.speedBoostValue or 50
		jumpPowerBoostEnabled = result.jumpPowerBoostEnabled or false
		jumpPowerBoostValue = result.jumpPowerBoostValue or 100
		infiniteJumpEnabled = result.infiniteJumpEnabled or false
		noclip = result.noclip or false
		if result.FlySpeed then FlySystem:setSpeed(result.FlySpeed) end

		-- For√ßar atualiza√ß√£o visual de TODOS os toggles
		task.wait(0.2)
		forceUpdateAllToggles()

		-- Aplicar configura√ß√µes funcionais
		if speedBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.WalkSpeed = speedBoostValue
				end
			end
		end
		
		if jumpPowerBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.JumpPower = jumpPowerBoostValue
				end
			end
		end
		
		if flying and not FlySystem.flying then
			FlySystem:toggleFly()
		elseif not flying and FlySystem.flying then
			FlySystem:toggleFly()
		end

		-- Aplicar ESP e outras configura√ß√µes visuais
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= LocalPlayer then
				refreshESPForPlayer(p)
			end
		end

		
		return true
	end
	return false
end

-- Fun√ß√£o para listar configs salvas
function listConfigs()
	local configs = {}
	local success, files = pcall(function()
		return listfiles("")
	end)
	
	if success and files then
		for _, file in ipairs(files) do
			if file:find("NightMenu_") and file:find(".json") then
				local configName = file:gsub("NightMenu_", ""):gsub(".json", "")
				local success2, data = pcall(function()
					local encoded = readfile(file)
					return HttpService:JSONDecode(encoded)
				end)
				if success2 and data then
					table.insert(configs, data)
				end
			end
		end
	end
	return configs
end

-- Container principal com 2 colunas
local configContainer = Instance.new("Frame")
configContainer.Size = UDim2.new(1, 0, 0, 400)
configContainer.BackgroundTransparency = 1
configContainer.Parent = configCategory

-- Coluna esquerda - Lista de configs
local configsList = Instance.new("ScrollingFrame")
configsList.Size = UDim2.new(0.6, -5, 1, 0)
configsList.Position = UDim2.new(0, 0, 0, 0)
configsList.BackgroundColor3 = Color3.fromRGB(32, 32, 38)
configsList.BorderSizePixel = 0
configsList.ScrollBarThickness = 6
configsList.Parent = configContainer
Instance.new("UICorner", configsList).CornerRadius = UDim.new(0, 8)

local configsLayout = Instance.new("UIListLayout")
configsLayout.Padding = UDim.new(0, 4)
configsLayout.Parent = configsList

configsLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
	configsList.CanvasSize = UDim2.new(0, 0, 0, configsLayout.AbsoluteContentSize.Y)
end)

-- Coluna direita - A√ß√µes
local actionsPanel = Instance.new("Frame")
actionsPanel.Size = UDim2.new(0.35, -5, 1, 0)
actionsPanel.Position = UDim2.new(0.65, 5, 0, 0)
actionsPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 70)
actionsPanel.BackgroundTransparency = 0.4
actionsPanel.Parent = configContainer
Instance.new("UICorner", actionsPanel).CornerRadius = UDim.new(0, 12)

local actionsTitle = Instance.new("TextLabel")
actionsTitle.Size = UDim2.new(1, -20, 0, 30)
actionsTitle.Position = UDim2.new(0, 10, 0, 10)
actionsTitle.BackgroundTransparency = 1
actionsTitle.Text = "NOVA CONFIG"
actionsTitle.Font = Enum.Font.SourceSansBold
actionsTitle.TextSize = 14
actionsTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
actionsTitle.TextXAlignment = Enum.TextXAlignment.Left
actionsTitle.Parent = actionsPanel

local actionsContainer = Instance.new("Frame")
actionsContainer.Size = UDim2.new(1, -20, 1, -50)
actionsContainer.Position = UDim2.new(0, 10, 0, 40)
actionsContainer.BackgroundTransparency = 1
actionsContainer.Parent = actionsPanel

local actionsLayout = Instance.new("UIListLayout")
actionsLayout.Padding = UDim.new(0, 8)
actionsLayout.Parent = actionsContainer

-- Input para nome da config
local configNameInput = Instance.new("TextBox")
configNameInput.Size = UDim2.new(1, 0, 0, 40)
configNameInput.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
configNameInput.TextColor3 = Color3.fromRGB(255, 255, 255)
configNameInput.PlaceholderText = "Nome da config..."
configNameInput.Font = Enum.Font.SourceSans
configNameInput.TextSize = 14
configNameInput.Text = ""
configNameInput.Parent = actionsContainer
Instance.new("UICorner", configNameInput).CornerRadius = UDim.new(0, 8)

-- Bot√£o Salvar
local saveBtn = Instance.new("TextButton")
saveBtn.Size = UDim2.new(1, 0, 0, 40)
saveBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
saveBtn.BackgroundTransparency = 0.2
saveBtn.Text = "üíæ SALVAR"
saveBtn.Font = Enum.Font.SourceSansBold
saveBtn.TextSize = 14
saveBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
saveBtn.Parent = actionsContainer
Instance.new("UICorner", saveBtn).CornerRadius = UDim.new(0, 8)

-- Bot√£o Exportar
local exportBtn = Instance.new("TextButton")
exportBtn.Size = UDim2.new(1, 0, 0, 40)
exportBtn.BackgroundColor3 = Color3.fromRGB(200, 100, 0)
exportBtn.BackgroundTransparency = 0.2
exportBtn.Text = "üì§ EXPORTAR"
exportBtn.Font = Enum.Font.SourceSansBold
exportBtn.TextSize = 14
exportBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
exportBtn.Parent = actionsContainer
Instance.new("UICorner", exportBtn).CornerRadius = UDim.new(0, 8)

-- Input para importar
local importInput = Instance.new("TextBox")
importInput.Size = UDim2.new(1, 0, 0, 80)
importInput.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
importInput.TextColor3 = Color3.fromRGB(255, 255, 255)
importInput.PlaceholderText = "Cole o c√≥digo aqui..."
importInput.Font = Enum.Font.SourceSans
importInput.TextSize = 12
importInput.Text = ""
importInput.TextWrapped = true
importInput.MultiLine = true
importInput.Parent = actionsContainer
Instance.new("UICorner", importInput).CornerRadius = UDim.new(0, 8)

-- Bot√£o Importar
local importBtn = Instance.new("TextButton")
importBtn.Size = UDim2.new(1, 0, 0, 40)
importBtn.BackgroundColor3 = Color3.fromRGB(0, 100, 200)
importBtn.BackgroundTransparency = 0.2
importBtn.Text = "üì• IMPORTAR"
importBtn.Font = Enum.Font.SourceSansBold
importBtn.TextSize = 14
importBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
importBtn.Parent = actionsContainer
Instance.new("UICorner", importBtn).CornerRadius = UDim.new(0, 8)

-- Fun√ß√£o para criar bot√£o de config na lista
function createConfigButton(config)
	if not config or not config.name or not config.date then return end
	
	local btn = Instance.new("Frame")
	btn.Size = UDim2.new(1, -8, 0, 60)
	btn.BackgroundColor3 = Color3.fromRGB(50, 50, 60)
	btn.Parent = configsList
	Instance.new("UICorner", btn).CornerRadius = UDim.new(0, 6)

	-- Nome da config
	local nameLabel = Instance.new("TextLabel")
	nameLabel.Size = UDim2.new(0.6, 0, 0, 25)
	nameLabel.Position = UDim2.new(0, 10, 0, 5)
	nameLabel.BackgroundTransparency = 1
	nameLabel.Font = Enum.Font.SourceSansBold
	nameLabel.TextSize = 14
	nameLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
	nameLabel.TextXAlignment = Enum.TextXAlignment.Left
	nameLabel.Text = tostring(config.name)
	nameLabel.Parent = btn

	-- Data de cria√ß√£o
	local dateLabel = Instance.new("TextLabel")
	dateLabel.Size = UDim2.new(0.6, 0, 0, 20)
	dateLabel.Position = UDim2.new(0, 10, 0, 30)
	dateLabel.BackgroundTransparency = 1
	dateLabel.Font = Enum.Font.SourceSans
	dateLabel.TextSize = 11
	dateLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
	dateLabel.TextXAlignment = Enum.TextXAlignment.Left
	dateLabel.Text = "üìÖ " .. tostring(config.date)
	dateLabel.Parent = btn

	local useBtn = Instance.new("TextButton")
	useBtn.Size = UDim2.new(0, 60, 0, 35)
	useBtn.Position = UDim2.new(1, -130, 0.5, -17)
	useBtn.BackgroundColor3 = Color3.fromRGB(0, 150, 0)
	useBtn.Text = "‚úì USAR"
	useBtn.Font = Enum.Font.SourceSansBold
	useBtn.TextSize = 13
	useBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	useBtn.Parent = btn
	Instance.new("UICorner", useBtn).CornerRadius = UDim.new(0, 6)

	-- Bot√£o DELETAR
	local deleteBtn = Instance.new("TextButton")
	deleteBtn.Size = UDim2.new(0, 60, 0, 35)
	deleteBtn.Position = UDim2.new(1, -65, 0.5, -17)
	deleteBtn.BackgroundColor3 = Color3.fromRGB(150, 0, 0)
	deleteBtn.Text = "üóëÔ∏è"
	deleteBtn.Font = Enum.Font.SourceSansBold
	deleteBtn.TextSize = 13
	deleteBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	deleteBtn.Parent = btn
	Instance.new("UICorner", deleteBtn).CornerRadius = UDim.new(0, 6)

	useBtn.MouseButton1Click:Connect(function()
		loadConfig(config.name)
		useBtn.Text = "‚úÖ OK"
		task.wait(1)
		useBtn.Text = "‚úì USAR"
	end)
	
	deleteBtn.MouseButton1Click:Connect(function()
		local success = pcall(function()
			delfile("NightMenu_" .. config.name .. ".json")
		end)
		if success then
			deleteBtn.Text = "‚úÖ"
			task.wait(0.5)
			btn:Destroy()
			refreshConfigsList()
		else
			deleteBtn.Text = "‚ùå"
			task.wait(1)
			deleteBtn.Text = "üóëÔ∏è"
		end
	end)

	return btn
end

-- Fun√ß√£o para atualizar lista de configs
function refreshConfigsList()
	for _, child in ipairs(configsList:GetChildren()) do
		if child:IsA("Frame") then
			child:Destroy()
		end
	end
	
	local success, configs = pcall(listConfigs)
	if success and configs then
		for _, config in ipairs(configs) do
			if config and config.name then
				createConfigButton(config)
			end
		end
	end
end

-- Bot√£o Salvar
saveBtn.MouseButton1Click:Connect(function()
	local configName = configNameInput.Text
	if configName == "" then
		configNameInput.PlaceholderText = "‚ùå Digite um nome!"
		return
	end
	
	local success = pcall(function()
		saveConfig(configName)
	end)
	
	if success then
		saveBtn.Text = "‚úÖ SALVA"
		configNameInput.Text = ""
		refreshConfigsList()
		task.wait(1)
		saveBtn.Text = "üíæ SALVAR"
	else
		saveBtn.Text = "‚ùå ERRO"
		task.wait(1)
		saveBtn.Text = "üíæ SALVAR"
	end
end)

-- Bot√£o Exportar
exportBtn.MouseButton1Click:Connect(function()
	local configName = configNameInput.Text
	if configName == "" then
		configNameInput.PlaceholderText = "‚ùå Digite um nome!"
		return
	end
	
	local success, result = pcall(function()
		local encoded = readfile("NightMenu_" .. configName .. ".json")
		return encoded
	end)
	
	if success and result then
		setclipboard(result)
		exportBtn.Text = "‚úÖ COPIADO"
		task.wait(1)
		exportBtn.Text = "üì§ EXPORTAR"
	else
		exportBtn.Text = "‚ùå N√ÉO EXISTE"
		task.wait(1)
		exportBtn.Text = "üì§ EXPORTAR"
	end
end)

-- Bot√£o Importar
importBtn.MouseButton1Click:Connect(function()
	local code = importInput.Text
	if code == "" then
		importInput.PlaceholderText = "‚ùå Cole o c√≥digo!"
		return
	end
	
	local success, config = pcall(function()
		return HttpService:JSONDecode(code)
	end)
	
	if success and config and config.name then
		local encoded = HttpService:JSONEncode(config)
		writefile("NightMenu_" .. config.name .. ".json", encoded)
		importBtn.Text = "‚úÖ IMPORTADA"
		importInput.Text = ""
		refreshConfigsList()
		task.wait(1)
		importBtn.Text = "üì• IMPORTAR"
	else
		importBtn.Text = "‚ùå C√ìDIGO INV√ÅLIDO"
		task.wait(1)
		importBtn.Text = "üì• IMPORTAR"
	end
end)

-- Carregar lista inicial
pcall(refreshConfigsList)

-- ESP Page
local espCategory = createCategory(espPage, "ESP Settings")

local espToggle = createToggle(espCategory, "ESP Ativado", function(enabled)
	espEnabled = enabled
	if not enabled then
		-- Limpar todos os ESPs quando desativado
		for char, highlight in pairs(highlights) do
			if highlight then pcall(function() highlight:Destroy() end) end
		end
		for char, overlay in pairs(overlays) do
			if overlay then pcall(function() overlay:Destroy() end) end
		end
		for char, box in pairs(boxes) do
			if box then pcall(function() box:Remove() end) end
		end
		for char, tracer in pairs(tracers) do
			if tracer then pcall(function() tracer:Remove() end) end
		end
		for char, label in pairs(distanceLabels) do
			if label then pcall(function() label:Remove() end) end
		end
		for char, label in pairs(nameLabels) do
			if label then pcall(function() label:Remove() end) end
		end
		for char, bar in pairs(healthBars) do
			if bar then
				pcall(function()
					if bar.bg then bar.bg:Remove() end
					if bar.fill then bar.fill:Remove() end
				end)
			end
		end
		highlights = {}
		overlays = {}
		boxes = {}
		tracers = {}
		distanceLabels = {}
		nameLabels = {}
		healthBars = {}
	end
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- Nome: Toggle + Cor
local nameFrame = Instance.new("Frame")
nameFrame.Size = UDim2.new(1, 0, 0, 42)
nameFrame.BackgroundTransparency = 1
nameFrame.Parent = espCategory

local nameToggle = createToggle(nameFrame, "Mostrar Nome", function(enabled)
	showName = enabled
	if not enabled then
		for char, label in pairs(nameLabels) do
			if label then pcall(function() label:Remove() end) end
		end
		nameLabels = {}
	end
end)
nameToggle.Size = UDim2.new(0.65, -5, 1, 0)
nameToggle.Position = UDim2.new(0, 0, 0, 0)

local nameColorBtn = Instance.new("TextButton")
nameColorBtn.Size = UDim2.new(0.35, -5, 1, 0)
nameColorBtn.Position = UDim2.new(0.65, 5, 0, 0)
nameColorBtn.BackgroundColor3 = espNameColor
nameColorBtn.Text = "üé®"
nameColorBtn.Font = Enum.Font.SourceSansBold
nameColorBtn.TextSize = 18
nameColorBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
nameColorBtn.Parent = nameFrame
Instance.new("UICorner", nameColorBtn).CornerRadius = UDim.new(0, 10)

local boxColors = {
	Color3.fromRGB(255, 0, 0), Color3.fromRGB(0, 255, 0), Color3.fromRGB(0, 0, 255),
	Color3.fromRGB(255, 255, 0), Color3.fromRGB(255, 0, 255), Color3.fromRGB(0, 255, 255),
	Color3.fromRGB(255, 255, 255)
}
local nameColorIndex = 7

nameColorBtn.MouseButton1Click:Connect(function()
	nameColorIndex = (nameColorIndex % #boxColors) + 1
	espNameColor = boxColors[nameColorIndex]
	nameColorBtn.BackgroundColor3 = espNameColor
	nameColorBtn.TextColor3 = nameColorIndex == 7 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
end)

-- Vida
local healthToggle = createToggle(espCategory, "Barra de Vida 2D (Esquerda)", function(enabled)
	showHealth = enabled
	if not enabled then
		for char, bar in pairs(healthBars) do
			if bar then
				pcall(function()
					if bar.bg then bar.bg:Remove() end
					if bar.fill then bar.fill:Remove() end
				end)
			end
		end
		healthBars = {}
	end
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- Box 3D: Toggle + Cor
local boxFrame = Instance.new("Frame")
boxFrame.Size = UDim2.new(1, 0, 0, 42)
boxFrame.BackgroundTransparency = 1
boxFrame.Parent = espCategory

local box3DToggle = createToggle(boxFrame, "Box", function(enabled)
	showBox3D = enabled
	if not enabled then
		-- Limpar todas as boxes quando desativado
		for char, box in pairs(boxes) do
			if box then pcall(function() box:Remove() end) end
		end
		boxes = {}
	end
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)
box3DToggle.Size = UDim2.new(0.65, -5, 1, 0)
box3DToggle.Position = UDim2.new(0, 0, 0, 0)

local boxColorBtn = Instance.new("TextButton")
boxColorBtn.Size = UDim2.new(0.35, -5, 1, 0)
boxColorBtn.Position = UDim2.new(0.65, 5, 0, 0)
boxColorBtn.BackgroundColor3 = espColor
boxColorBtn.Text = "üé®"
boxColorBtn.Font = Enum.Font.SourceSansBold
boxColorBtn.TextSize = 18
boxColorBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
boxColorBtn.Parent = boxFrame
Instance.new("UICorner", boxColorBtn).CornerRadius = UDim.new(0, 10)

local boxColorIndex = 1

boxColorBtn.MouseButton1Click:Connect(function()
	boxColorIndex = (boxColorIndex % #boxColors) + 1
	espColor = boxColors[boxColorIndex]
	boxColorBtn.BackgroundColor3 = espColor
end)

-- Tracers: Toggle + Cor
local tracersFrame = Instance.new("Frame")
tracersFrame.Size = UDim2.new(1, 0, 0, 42)
tracersFrame.BackgroundTransparency = 1
tracersFrame.Parent = espCategory

local tracersToggle = createToggle(tracersFrame, "Tracers (Linhas)", function(enabled)
	showTracers = enabled
	if not enabled then
		for char, tracer in pairs(tracers) do
			if tracer then pcall(function() tracer:Remove() end) end
		end
		tracers = {}
	end
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)
tracersToggle.Size = UDim2.new(0.65, -5, 1, 0)
tracersToggle.Position = UDim2.new(0, 0, 0, 0)

local tracerColorBtn = Instance.new("TextButton")
tracerColorBtn.Size = UDim2.new(0.35, -5, 1, 0)
tracerColorBtn.Position = UDim2.new(0.65, 5, 0, 0)
tracerColorBtn.BackgroundColor3 = espTracerColor
tracerColorBtn.Text = "üé®"
tracerColorBtn.Font = Enum.Font.SourceSansBold
tracerColorBtn.TextSize = 18
tracerColorBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
tracerColorBtn.Parent = tracersFrame
Instance.new("UICorner", tracerColorBtn).CornerRadius = UDim.new(0, 10)

local tracerColorIndex = 7

tracerColorBtn.MouseButton1Click:Connect(function()
	tracerColorIndex = (tracerColorIndex % #boxColors) + 1
	espTracerColor = boxColors[tracerColorIndex]
	tracerColorBtn.BackgroundColor3 = espTracerColor
	tracerColorBtn.TextColor3 = tracerColorIndex == 7 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
end)

-- Dist√¢ncia: Toggle + Cor
local distFrame = Instance.new("Frame")
distFrame.Size = UDim2.new(1, 0, 0, 42)
distFrame.BackgroundTransparency = 1
distFrame.Parent = espCategory

local espDistToggle = createToggle(distFrame, "Mostrar Dist√¢ncia (m)", function(enabled)
	showEspDistance = enabled
	if not enabled then
		for char, label in pairs(distanceLabels) do
			if label then pcall(function() label:Remove() end) end
		end
		distanceLabels = {}
	end
end)
espDistToggle.Size = UDim2.new(0.65, -5, 1, 0)
espDistToggle.Position = UDim2.new(0, 0, 0, 0)

local distColorBtn = Instance.new("TextButton")
distColorBtn.Size = UDim2.new(0.35, -5, 1, 0)
distColorBtn.Position = UDim2.new(0.65, 5, 0, 0)
distColorBtn.BackgroundColor3 = espDistanceColor
distColorBtn.Text = "üé®"
distColorBtn.Font = Enum.Font.SourceSansBold
distColorBtn.TextSize = 18
distColorBtn.TextColor3 = Color3.fromRGB(0, 0, 0)
distColorBtn.Parent = distFrame
Instance.new("UICorner", distColorBtn).CornerRadius = UDim.new(0, 10)

local distColorIndex = 4

distColorBtn.MouseButton1Click:Connect(function()
	distColorIndex = (distColorIndex % #boxColors) + 1
	espDistanceColor = boxColors[distColorIndex]
	distColorBtn.BackgroundColor3 = espDistanceColor
	distColorBtn.TextColor3 = distColorIndex == 4 and Color3.fromRGB(0, 0, 0) or Color3.fromRGB(255, 255, 255)
end)

-- Outros toggles
local skeletonToggle = createToggle(espCategory, "Esqueleto (ESP de Corpo)", function(enabled)
	showSkeleton = enabled
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- Configura√ß√µes avan√ßadas
local modeBtn = Instance.new("TextButton")
modeBtn.Size = UDim2.new(1, 0, 0, 40)
modeBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
modeBtn.BackgroundTransparency = 0.2
modeBtn.Text = "Modo: " .. espMode
modeBtn.Font = Enum.Font.SourceSans
modeBtn.TextSize = 14
modeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
modeBtn.Parent = espCategory
Instance.new("UICorner", modeBtn).CornerRadius = UDim.new(0, 8)

modeBtn.MouseButton1Click:Connect(function()
	espMode = (espMode == "Cheio") and "Bordas" or "Cheio"
	modeBtn.Text = "Modo: " .. espMode
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

local autoEspToggle = createToggle(espCategory, "ESP Autom√°tico (Vis√≠vel/Invis√≠vel)", function(enabled)
	espAutoEnabled = enabled
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

local tracerModeBtn = Instance.new("TextButton")
tracerModeBtn.Size = UDim2.new(1, 0, 0, 40)
tracerModeBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
tracerModeBtn.BackgroundTransparency = 0.2
tracerModeBtn.Text = "Modo Tracer: " .. tracerMode
tracerModeBtn.Font = Enum.Font.SourceSans
tracerModeBtn.TextSize = 14
tracerModeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
tracerModeBtn.Parent = espCategory
Instance.new("UICorner", tracerModeBtn).CornerRadius = UDim.new(0, 8)

tracerModeBtn.MouseButton1Click:Connect(function()
	tracerMode = (tracerMode == "Sky") and "Center" or "Sky"
	tracerModeBtn.Text = "Modo Tracer: " .. tracerMode
end)

-- ESP Distance Slider
local espDistanceFrame = Instance.new("Frame")
espDistanceFrame.Size = UDim2.new(1, 0, 0, 45)
espDistanceFrame.BackgroundTransparency = 1
espDistanceFrame.Parent = espCategory

local espDistTitle = Instance.new("TextLabel")
espDistTitle.BackgroundTransparency = 1
espDistTitle.Size = UDim2.new(0.4, 0, 0, 14)
espDistTitle.Font = Enum.Font.SourceSansBold
espDistTitle.TextSize = 12
espDistTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
espDistTitle.Text = "Dist√¢ncia ESP"
espDistTitle.Parent = espDistanceFrame

local espDistLabel = Instance.new("TextLabel")
espDistLabel.BackgroundTransparency = 1
espDistLabel.Size = UDim2.new(0.6, 0, 0, 14)
espDistLabel.Position = UDim2.new(0.4, 0, 0, 0)
espDistLabel.Font = Enum.Font.SourceSans
espDistLabel.TextSize = 12
espDistLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
espDistLabel.Text = ESP_MAX_DISTANCE
espDistLabel.Parent = espDistanceFrame

local espDistSlider = Instance.new("Frame")
espDistSlider.Size = UDim2.new(0.8, 0, 0, 16)
espDistSlider.Position = UDim2.new(0.1, 0, 0, 16)
espDistSlider.BackgroundColor3 = COLOR_SLIDER_TRACK
espDistSlider.Parent = espDistanceFrame
Instance.new("UICorner", espDistSlider).CornerRadius = UDim.new(0, 5)

local espDistFill = Instance.new("Frame")
espDistFill.Size = UDim2.fromScale(ESP_MAX_DISTANCE / 500, 1)
espDistFill.BackgroundColor3 = COLOR_NEON_PINK
espDistFill.Parent = espDistSlider
Instance.new("UICorner", espDistFill).CornerRadius = UDim.new(0, 4)

local espDistDrag = false
espDistSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		espDistDrag = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		espDistDrag = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if espDistDrag and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = espDistSlider.AbsolutePosition
		local sliderSize = espDistSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		ESP_MAX_DISTANCE = math.floor(50 + relativeX * 450)
		espDistLabel.Text = tostring(ESP_MAX_DISTANCE)
		espDistFill.Size = UDim2.fromScale(relativeX, 1)
	end
end)

-- ESP Position Selector
local positionBtn = Instance.new("TextButton")
positionBtn.Size = UDim2.new(1, 0, 0, 40)
positionBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
positionBtn.BackgroundTransparency = 0.2
positionBtn.Text = "Posi√ß√£o: " .. espPosition
positionBtn.Font = Enum.Font.SourceSans
positionBtn.TextSize = 14
positionBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
positionBtn.Parent = espCategory
Instance.new("UICorner", positionBtn).CornerRadius = UDim.new(0, 8)

positionBtn.MouseButton1Click:Connect(function()
	if espPosition == "Topo" then
		espPosition = "Baixo"
	elseif espPosition == "Baixo" then
		espPosition = "Lado"
	else
		espPosition = "Topo"
	end
	positionBtn.Text = "Posi√ß√£o: " .. espPosition
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- Aimbot Page - Reorganizado e Melhorado
local rageCategory = createCategory(aimbotPage, "Aimbot")

-- Toggles organizados em grid 2x2
local togglesFrame = Instance.new("Frame")
togglesFrame.Size = UDim2.new(1, 0, 0, 110)
togglesFrame.BackgroundTransparency = 1
togglesFrame.Parent = rageCategory

local aimbotToggle = createToggle(togglesFrame, "Aimbot", function(enabled)
	aimbotEnabled = enabled
end)
aimbotToggle.Position = UDim2.new(0, 0, 0, 0)
aimbotToggle.Size = UDim2.new(0.48, 0, 0, 50)

local fovToggle = createToggle(togglesFrame, "Mostrar FOV", function(enabled)
	aimbotShowFOV = enabled
	local existing = gui:FindFirstChild("FOVCircle")
	if aimbotShowFOV then
		if not existing then
			local fovCircle = Instance.new("Frame")
			fovCircle.Name = "FOVCircle"
			fovCircle.Size = UDim2.fromOffset(aimbotFOV * 3, aimbotFOV * 3)
			fovCircle.Position = UDim2.new(0.5, -aimbotFOV * 1.5, 0.5, -aimbotFOV * 1.5)
			fovCircle.BackgroundTransparency = 1
			fovCircle.BorderSizePixel = 0
			fovCircle.ZIndex = 10
			Instance.new("UICorner", fovCircle).CornerRadius = UDim.new(1, 0)
			local stroke = Instance.new("UIStroke")
			stroke.Color = Color3.new(1, 1, 1)
			stroke.Thickness = 2
			stroke.Parent = fovCircle
			fovCircle.Parent = gui
		end
	else
		if existing then existing:Destroy() end
	end
end)
fovToggle.Position = UDim2.new(0.52, 0, 0, 0)
fovToggle.Size = UDim2.new(0.48, 0, 0, 50)

local visibleToggle = createToggle(togglesFrame, "Apenas Vis√≠veis", function(enabled)
	aimbotOnlyVisible = enabled
end)
visibleToggle.Position = UDim2.new(0, 0, 0, 55)
visibleToggle.Size = UDim2.new(0.48, 0, 0, 50)

local mobileToggle = createToggle(togglesFrame, "FOV M√≥vel", function(enabled)
	aimbotMobile = enabled
end)
mobileToggle.Position = UDim2.new(0.52, 0, 0, 55)
mobileToggle.Size = UDim2.new(0.48, 0, 0, 50)

-- Auto Kill Toggle - Sistema Ultra Agressivo
autoKillEnabled = false
autoKillCurrentTarget = nil
autoKillLastAttack = 0
autoKillClickActive = false
autoKillCycleState = 0
autoKillCycleTimer = 0
autoKillAttackSpeed = 0.3 -- Velocidade de ataque ultra r√°pida
autoKillAttackPosition = 0 -- 0=tr√°s, 1=frente, 2=lado esquerdo, 3=lado direito
autoKillCooldownActive = false -- Cooldown ap√≥s kills
autoKillLastEnemyCount = 0 -- Contador de inimigos anterior
autoKillAttackCount = 0 -- Contador de ataques no alvo atual

local autoKillToggle = createToggle(rageCategory, "üó°Ô∏è Auto Kill Ultra Agressivo", function(enabled)
	autoKillEnabled = enabled
	if enabled then
		autoKillCurrentTarget = nil
		autoKillStats.enemiesKilled = 0
		autoKillStats.waitingForRound = false
		
		task.spawn(function()
			while autoKillEnabled do
				task.wait(0.05)
				
				-- Verificar se est√° em cooldown
				if autoKillCooldownActive then
					if autoKillStatusLabel then
						autoKillStatusLabel.Text = "‚è≥ Aguardando 8s ap√≥s kills..."
						autoKillStatusLabel.TextColor3 = Color3.fromRGB(255, 150, 0)
					end
					continue
				end
				
				autoKillStats.enemiesAlive = countEnemies()
				autoKillStats.roundTimer = getRoundTimer() or 0
				
				-- Detectar se matou todos os inimigos
				if autoKillLastEnemyCount > 0 and autoKillStats.enemiesAlive == 0 and not autoKillCooldownActive then
					autoKillCooldownActive = true
					autoKillCurrentTarget = nil
					autoKillCycleState = 0
					autoKillCycleTimer = 0
					autoKillAttackPosition = 0
					autoKillStats.enemiesKilled = autoKillStats.enemiesKilled + autoKillLastEnemyCount
					
					if autoKillStatusLabel then
						autoKillStatusLabel.Text = "‚úÖ Todos mortos! Aguardando 8s..."
						autoKillStatusLabel.TextColor3 = Color3.fromRGB(0, 255, 0)
					end
					
					-- Esperar 8 segundos
					task.wait(8)
					autoKillCooldownActive = false
					autoKillLastEnemyCount = 0
					
					-- Resetar completamente o sistema
					autoKillCurrentTarget = nil
					autoKillCycleState = 0
					autoKillCycleTimer = 0
					autoKillAttackPosition = 0
					continue
				end
				
				-- Atualizar contador anterior
				autoKillLastEnemyCount = autoKillStats.enemiesAlive
				
				if autoKillStatusLabel then
					if autoKillStats.waitingForRound then
						autoKillStatusLabel.Text = string.format("‚è≥ Aguardando | Timer: %ds | Inimigos: %d", autoKillStats.roundTimer, autoKillStats.enemiesAlive)
						autoKillStatusLabel.TextColor3 = Color3.fromRGB(255, 200, 0)
					else
						autoKillStatusLabel.Text = string.format("‚öîÔ∏è Matando | Inimigos: %d | Mortos: %d", autoKillStats.enemiesAlive, autoKillStats.enemiesKilled)
						autoKillStatusLabel.TextColor3 = Color3.fromRGB(0, 255, 100)
					end
				end
				
				if autoKillStats.enemiesAlive == 0 and not autoKillStats.waitingForRound and not autoKillCooldownActive then
					autoKillStats.waitingForRound = true
					autoKillStats.enemiesKilled = 0
					continue
				end
				
				if autoKillStats.waitingForRound then
					if autoKillStats.roundTimer <= 1 and autoKillStats.roundTimer > 0 then
						local char = LocalPlayer.Character
						if char then
							local root = char:FindFirstChild("HumanoidRootPart")
							if root then
								root.CFrame = CFrame.new(0, 100, 0)
							end
						end
						task.wait(3)
						autoKillStats.waitingForRound = false
						autoKillStats.enemiesKilled = 0
					end
					if autoKillStats.enemiesAlive > 0 then
						autoKillStats.waitingForRound = false
					end
					continue
				end
				
				-- N√£o fazer nada se estiver em cooldown
				if autoKillCooldownActive then
					continue
				end
				
				local character = LocalPlayer.Character
				if not character then continue end
				local myRoot = character:FindFirstChild("HumanoidRootPart")
				if not myRoot then continue end
				
				local weapon = findWeaponOrKnife()
				if weapon and weapon.Parent ~= character then
					weapon.Parent = character
					task.wait(0.05)
				end
				
				if weapon and killRangeEnabled then
					extendToolRange(weapon, 35)
				end
				
				if not autoKillCurrentTarget or not autoKillCurrentTarget.Character then
					autoKillCurrentTarget = nil
					autoKillCycleState = 0
					autoKillCycleTimer = 0
					autoKillAttackPosition = 0
					autoKillAttackCount = 0
					
					for _, player in ipairs(Players:GetPlayers()) do
						if player ~= LocalPlayer and player.Character then
							local hum = player.Character:FindFirstChildOfClass("Humanoid")
							local root = player.Character:FindFirstChild("HumanoidRootPart")
							if hum and hum.Health > 0 and root and isInSameDimension(player.Character) and isEnemy(player) then
								autoKillCurrentTarget = player
								autoKillCycleState = 0
								autoKillCycleTimer = 0
								autoKillAttackPosition = 0
								autoKillAttackCount = 0
								break
							end
						end
					end
				else
					local hum = autoKillCurrentTarget.Character:FindFirstChildOfClass("Humanoid")
					if not hum or hum.Health <= 0 or not isInSameDimension(autoKillCurrentTarget.Character) then
						autoKillCurrentTarget = nil
						autoKillCycleState = 0
						autoKillCycleTimer = 0
						autoKillAttackPosition = 0
						autoKillAttackCount = 0
						autoKillStats.enemiesKilled = autoKillStats.enemiesKilled + 1
						continue
					end
				end
				
				if autoKillCurrentTarget and autoKillCurrentTarget.Character then
					local targetRoot = autoKillCurrentTarget.Character:FindFirstChild("HumanoidRootPart")
					if targetRoot then
						autoKillCycleTimer = autoKillCycleTimer + 0.05
						
						if autoKillCycleState == 0 then
							-- Fase de ataque: TP instant√¢neo e ataque triplo
							local attackOffset
							if autoKillAttackPosition == 0 then
								attackOffset = CFrame.new(0, 0, 1) -- Tr√°s (mais perto)
							elseif autoKillAttackPosition == 1 then
								attackOffset = CFrame.new(0, 0, -1) -- Frente
							elseif autoKillAttackPosition == 2 then
								attackOffset = CFrame.new(-1, 0, 0) -- Esquerda
							else
								attackOffset = CFrame.new(1, 0, 0) -- Direita
							end
							
							-- TP instant√¢neo
							myRoot.CFrame = CFrame.new(targetRoot.Position) * attackOffset
							myRoot.AssemblyLinearVelocity = Vector3.zero
							
							-- Ataque triplo ultra r√°pido
							if weapon then
								for i = 1, 3 do
									weapon:Activate()
									task.wait(0.01)
								end
							end
							
							autoKillAttackCount = autoKillAttackCount + 1
							
							if autoKillCycleTimer >= autoKillAttackSpeed then
								autoKillCycleState = 1
								autoKillCycleTimer = 0
								-- Alternar posi√ß√£o para pr√≥ximo ataque
								autoKillAttackPosition = (autoKillAttackPosition + 1) % 4
							end
						else
							-- Fase de escape: teleportar para baixo ultra r√°pido
							myRoot.CFrame = CFrame.new(targetRoot.Position.X, -800, targetRoot.Position.Z)
							myRoot.AssemblyLinearVelocity = Vector3.zero
							
							if autoKillCycleTimer >= 0.1 then
								autoKillCycleState = 0
								autoKillCycleTimer = 0
								
								-- Se j√° atacou 5 vezes, trocar de alvo
								if autoKillAttackCount >= 5 then
									autoKillCurrentTarget = nil
									autoKillAttackCount = 0
								end
							end
						end
					end
				end
			end
		end)
	else
		autoKillCurrentTarget = nil
		autoKillCooldownActive = false
		autoKillLastEnemyCount = 0
		autoKillCycleState = 0
		autoKillCycleTimer = 0
		autoKillAttackPosition = 0
		autoKillAttackCount = 0
		if autoKillStatusLabel then
			autoKillStatusLabel.Text = "Status: Desativado"
			autoKillStatusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
		end
	end
end)
-- Status Display
local autoKillStatusLabel = Instance.new("TextLabel")
autoKillStatusLabel.Size = UDim2.new(1, 0, 0, 30)
autoKillStatusLabel.BackgroundColor3 = Color3.fromRGB(20, 20, 30)
autoKillStatusLabel.BackgroundTransparency = 0.3
autoKillStatusLabel.Text = "Status: Desativado"
autoKillStatusLabel.Font = Enum.Font.GothamBold
autoKillStatusLabel.TextSize = 12
autoKillStatusLabel.TextColor3 = Color3.fromRGB(150, 150, 150)
autoKillStatusLabel.Parent = rageCategory
Instance.new("UICorner", autoKillStatusLabel).CornerRadius = UDim.new(0, 6)

-- Sistema de clique para multi kill (5 metros)
UserInputService.InputBegan:Connect(function(input, processed)
	if not autoKillEnabled then return end
	
	if input.UserInputType == Enum.UserInputType.MouseButton1 and not autoKillClickActive then
		autoKillClickActive = true
		
		task.spawn(function()
			local character = LocalPlayer.Character
			if not character then
				autoKillClickActive = false
				return
			end
			
			local myRoot = character:FindFirstChild("HumanoidRootPart")
			if not myRoot then
				autoKillClickActive = false
				return
			end
			
			local weapon = findWeaponOrKnife()
			if weapon and weapon.Parent ~= character then
				weapon.Parent = character
				task.wait(0.05)
			end
			
			-- Pegar todos dentro de 10 metros (aumentado)
			local targets = {}
			for _, player in ipairs(Players:GetPlayers()) do
				if player ~= LocalPlayer and player.Character then
					local hum = player.Character:FindFirstChildOfClass("Humanoid")
					local root = player.Character:FindFirstChild("HumanoidRootPart")
					if hum and hum.Health > 0 and root and isInSameDimension(player.Character) and isEnemy(player) then
						local dist = (root.Position - myRoot.Position).Magnitude
						if dist <= 10 then
							table.insert(targets, player)
						end
					end
				end
			end
			
			if #targets == 0 then
				autoKillClickActive = false
				return
			end
			
			for _, target in ipairs(targets) do
				if target.Character then
					local targetRoot = target.Character:FindFirstChild("HumanoidRootPart")
					
					if targetRoot then
						-- Ataque qu√°druplo instant√¢neo
						for i = 1, 4 do
							myRoot.CFrame = CFrame.new(targetRoot.Position.X, -700, targetRoot.Position.Z)
							myRoot.AssemblyLinearVelocity = Vector3.zero
							
							if weapon then
								weapon:Activate()
							end
							
							task.wait(0.01)
						end
					end
				end
			end
			
			task.wait(0.1)
			autoKillClickActive = false
		end)
	end
end)

-- Dropdown para alvo
local targetDropdownFrame = Instance.new("Frame")
targetDropdownFrame.Size = UDim2.new(1, 0, 0, 50)
targetDropdownFrame.BackgroundTransparency = 1
targetDropdownFrame.Parent = rageCategory

local targetDropdownBtn = Instance.new("TextButton")
targetDropdownBtn.Size = UDim2.new(1, 0, 0, 40)
targetDropdownBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
targetDropdownBtn.BackgroundTransparency = 0.2
targetDropdownBtn.Text = "Alvo: " .. aimbotTarget .. " ‚ñº"
targetDropdownBtn.Font = Enum.Font.SourceSans
targetDropdownBtn.TextSize = 14
targetDropdownBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
targetDropdownBtn.Parent = targetDropdownFrame
Instance.new("UICorner", targetDropdownBtn).CornerRadius = UDim.new(0, 8)

local targetDropdownList = Instance.new("Frame")
targetDropdownList.Size = UDim2.new(1, 0, 0, 80)
targetDropdownList.BackgroundColor3 = Color3.fromRGB(40, 40, 50)
targetDropdownList.BackgroundTransparency = 0.1
targetDropdownList.Visible = false
targetDropdownList.Parent = targetDropdownFrame
Instance.new("UICorner", targetDropdownList).CornerRadius = UDim.new(0, 8)

local targetListLayout = Instance.new("UIListLayout")
targetListLayout.Padding = UDim.new(0, 2)
targetListLayout.Parent = targetDropdownList

for _, option in ipairs(targetOptions) do
	local optionBtn = Instance.new("TextButton")
	optionBtn.Size = UDim2.new(1, 0, 0, 25)
	optionBtn.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	optionBtn.BackgroundTransparency = 0.3
	optionBtn.Text = option
	optionBtn.Font = Enum.Font.SourceSans
	optionBtn.TextSize = 12
	optionBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
	optionBtn.Parent = targetDropdownList
	Instance.new("UICorner", optionBtn).CornerRadius = UDim.new(0, 6)

	optionBtn.MouseButton1Click:Connect(function()
		aimbotTarget = option
		targetDropdownBtn.Text = "Alvo: " .. aimbotTarget .. " ‚ñº"
		targetDropdownList.Visible = false
		targetDropdownOpen = false
	end)
end

targetDropdownBtn.MouseButton1Click:Connect(function()
	targetDropdownOpen = not targetDropdownOpen
	targetDropdownList.Visible = targetDropdownOpen
end)



-- FOV Slider compacto - Mais pequeno e mais grosso
local fovFrame = Instance.new("Frame")
fovFrame.Size = UDim2.new(1, 0, 0, 45)
fovFrame.BackgroundTransparency = 1
fovFrame.Parent = rageCategory

local fovTitle = Instance.new("TextLabel")
fovTitle.BackgroundTransparency = 1
fovTitle.Size = UDim2.new(0.4, 0, 0, 14)
fovTitle.Font = Enum.Font.SourceSansBold
fovTitle.TextSize = 12
fovTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
fovTitle.Text = "FOV"
fovTitle.Parent = fovFrame

local fovLabel = Instance.new("TextLabel")
fovLabel.BackgroundTransparency = 1
fovLabel.Size = UDim2.new(0.3, 0, 0, 14)
fovLabel.Position = UDim2.new(0.4, 0, 0, 0)
fovLabel.Font = Enum.Font.SourceSans
fovLabel.TextSize = 12
fovLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fovLabel.Text = aimbotFOV
fovLabel.Parent = fovFrame

local fovInput = Instance.new("TextBox")
fovInput.Size = UDim2.new(0.3, 0, 0, 14)
fovInput.Position = UDim2.new(0.7, 0, 0, 0)
fovInput.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
fovInput.TextColor3 = Color3.fromRGB(255, 255, 255)
fovInput.Text = tostring(aimbotFOV)
fovInput.Font = Enum.Font.SourceSans
fovInput.TextSize = 10
fovInput.Parent = fovFrame
Instance.new("UICorner", fovInput).CornerRadius = UDim.new(0, 4)

local fovSlider = Instance.new("Frame")
fovSlider.Size = UDim2.new(0.8, 0, 0, 16)
fovSlider.Position = UDim2.new(0.1, 0, 0, 16)
fovSlider.BackgroundColor3 = COLOR_SLIDER_TRACK
fovSlider.Parent = fovFrame
Instance.new("UICorner", fovSlider).CornerRadius = UDim.new(0, 5)

local fovFill = Instance.new("Frame")
fovFill.Size = UDim2.fromScale(aimbotFOV / 200, 1)
fovFill.BackgroundColor3 = COLOR_NEON_PINK
fovFill.Parent = fovSlider
Instance.new("UICorner", fovFill).CornerRadius = UDim.new(0, 4)

local fovDragging = false
fovSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		fovDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		fovDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if fovDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = fovSlider.AbsolutePosition
		local sliderSize = fovSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		aimbotFOV = math.floor(0 + relativeX * 200)
		fovLabel.Text = aimbotFOV
		fovInput.Text = tostring(aimbotFOV)
		fovFill.Size = UDim2.fromScale(relativeX, 1)
		local existing = gui:FindFirstChild("FOVCircle")
		if existing then
			existing.Size = UDim2.fromOffset(aimbotFOV * 3, aimbotFOV * 3)
			existing.Position = UDim2.new(0.5, -aimbotFOV * 1.5, 0.5, -aimbotFOV * 1.5)
		end
	end
end)

fovInput.FocusLost:Connect(function(enterPressed)
	if enterPressed then
		local newValue = tonumber(fovInput.Text)
		if newValue and newValue >= 0 and newValue <= 200 then
			aimbotFOV = newValue
			fovLabel.Text = aimbotFOV
			fovFill.Size = UDim2.fromScale(aimbotFOV / 200, 1)
			local existing = gui:FindFirstChild("FOVCircle")
			if existing then
				existing.Size = UDim2.fromOffset(aimbotFOV * 3, aimbotFOV * 3)
				existing.Position = UDim2.new(0.5, -aimbotFOV * 1.5, 0.5, -aimbotFOV * 1.5)
			end
		else
			fovInput.Text = tostring(aimbotFOV)
		end
	end
end)

-- Smooth Slider compacto - Mais pequeno e mais grosso
local smoothFrame = Instance.new("Frame")
smoothFrame.Size = UDim2.new(1, 0, 0, 45)
smoothFrame.BackgroundTransparency = 1
smoothFrame.Parent = rageCategory

local smoothTitle = Instance.new("TextLabel")
smoothTitle.BackgroundTransparency = 1
smoothTitle.Size = UDim2.new(0.4, 0, 0, 14)
smoothTitle.Font = Enum.Font.SourceSansBold
smoothTitle.TextSize = 12
smoothTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
smoothTitle.Text = "Smooth (0=Melhor)"
smoothTitle.Parent = smoothFrame

local smoothLabel = Instance.new("TextLabel")
smoothLabel.BackgroundTransparency = 1
smoothLabel.Size = UDim2.new(0.6, 0, 0, 14)
smoothLabel.Position = UDim2.new(0.4, 0, 0, 0)
smoothLabel.Font = Enum.Font.SourceSans
smoothLabel.TextSize = 12
smoothLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
smoothLabel.Text = aimbotSmooth
smoothLabel.Parent = smoothFrame

local smoothSlider = Instance.new("Frame")
smoothSlider.Size = UDim2.new(0.8, 0, 0, 16)
smoothSlider.Position = UDim2.new(0.1, 0, 0, 16)
smoothSlider.BackgroundColor3 = COLOR_SLIDER_TRACK
smoothSlider.Parent = smoothFrame
Instance.new("UICorner", smoothSlider).CornerRadius = UDim.new(0, 5)

local smoothFill = Instance.new("Frame")
smoothFill.Size = UDim2.fromScale(aimbotSmooth / 20, 1)
smoothFill.BackgroundColor3 = COLOR_NEON_PINK
smoothFill.Parent = smoothSlider
Instance.new("UICorner", smoothFill).CornerRadius = UDim.new(0, 4)

local smoothDragging = false
smoothSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		smoothDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		smoothDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if smoothDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = smoothSlider.AbsolutePosition
		local sliderSize = smoothSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		aimbotSmooth = math.floor(0 + relativeX * 20)
		smoothLabel.Text = aimbotSmooth
		smoothFill.Size = UDim2.fromScale(aimbotSmooth / 20, 1)
	end
end)

-- Bind Button
local bindBtn = Instance.new("TextButton")
bindBtn.Size = UDim2.new(1, 0, 0, 45)
bindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
bindBtn.BackgroundTransparency = 0.2
bindBtn.Text = "Bind: " .. aimbotBindString
bindBtn.Font = Enum.Font.SourceSans
bindBtn.TextSize = 14
bindBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
bindBtn.Parent = rageCategory
Instance.new("UICorner", bindBtn).CornerRadius = UDim.new(0, 8)

local bindListening = false
bindBtn.MouseButton1Click:Connect(function()
	bindListening = true
	bindBtn.Text = "Press any key..."
	bindBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if bindListening and not processed then
		if input.UserInputType == Enum.UserInputType.Keyboard then
			aimbotBind = input.KeyCode
			aimbotBindString = input.KeyCode.Name
		elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
			aimbotBind = "MouseLeft"
			aimbotBindString = "MouseLeft"
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			aimbotBind = "MouseRight"
			aimbotBindString = "MouseRight"
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			aimbotBind = "MouseMiddle"
			aimbotBindString = "MouseMiddle"
		elseif input.UserInputType == Enum.UserInputType.MouseButton4 then
			aimbotBind = "MouseButton4"
			aimbotBindString = "MouseButton4"
		elseif input.UserInputType == Enum.UserInputType.MouseButton5 then
			aimbotBind = "MouseButton5"
			aimbotBindString = "MouseButton5"
		else
			return -- Ignore other inputs
		end
		bindBtn.Text = "Bind: " .. aimbotBindString
		bindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
		bindListening = false
	end
end)

-- Loop para atualizar FOV m√≥vel
RunService.RenderStepped:Connect(function()
	if aimbotShowFOV and aimbotMobile then
		local fovCircle = gui:FindFirstChild("FOVCircle")
		if fovCircle then
			local mousePos = UserInputService:GetMouseLocation()
			fovCircle.Position = UDim2.new(0, mousePos.X - aimbotFOV * 1.5, 0, mousePos.Y - aimbotFOV * 1.5)
		end
	end
end)

-- Util Page - Reorganizada e Otimizada
local miscCategory = createCategory(utilPage, "Utilit√°rios")

-- ========= SUBCATEGORIA: MOVIMENTO =========
local movementSubCategory = Instance.new("Frame")
movementSubCategory.Size = UDim2.new(1, -20, 0, 0)
movementSubCategory.Position = UDim2.new(0, 10, 0, 10)
movementSubCategory.BackgroundColor3 = Color3.fromRGB(25, 25, 45)
movementSubCategory.BackgroundTransparency = 0.3
movementSubCategory.Parent = miscCategory
Instance.new("UICorner", movementSubCategory).CornerRadius = UDim.new(0, 10)

local movementTitle = Instance.new("TextLabel")
movementTitle.Size = UDim2.new(1, -20, 0, 25)
movementTitle.Position = UDim2.new(0, 10, 0, 5)
movementTitle.BackgroundTransparency = 1
movementTitle.Text = "üöÄ MOVIMENTO"
movementTitle.Font = Enum.Font.SourceSansBold
movementTitle.TextSize = 14
movementTitle.TextColor3 = Color3.fromRGB(139, 92, 246)
movementTitle.TextXAlignment = Enum.TextXAlignment.Left
movementTitle.Parent = movementSubCategory

local movementContent = Instance.new("Frame")
movementContent.Size = UDim2.new(1, -20, 1, -35)
movementContent.Position = UDim2.new(0, 10, 0, 30)
movementContent.BackgroundTransparency = 1
movementContent.Parent = movementSubCategory

local movementLayout = Instance.new("UIListLayout")
movementLayout.Padding = UDim.new(0, 6)
movementLayout.Parent = movementContent

-- Toggle do fly no menu - controle principal
local flyToggle = createToggle(movementContent, "‚úàÔ∏è Fly (F) - Ativa Noclip Auto", function(enabled)
	if enabled then
		-- Quando ativado no menu, for√ßa ativa√ß√£o
		if not FlySystem.flying then
			toggleFly()
		end
		-- Ativar noclip automaticamente quando fly √© ligado
		noclip = true
		-- Ativar noclip no toggle do menu tamb√©m
		if noclipToggle then
			local checkbox = noclipToggle:FindFirstChildOfClass("TextButton")
			if checkbox then
				checkbox.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
			end
		end
	else
		-- Quando desativado no menu, for√ßa desativa√ß√£o
		if FlySystem.flying then
			FlySystem:toggleFly() -- For√ßa desativa√ß√£o
			flying = false
		end
	end
end)

-- TextBox para velocidade do Fly
local flySpeedFrame = Instance.new("Frame")
flySpeedFrame.Size = UDim2.new(1, 0, 0, 35)
flySpeedFrame.BackgroundTransparency = 1
flySpeedFrame.Parent = movementContent

local flySpeedLabel = Instance.new("TextLabel")
flySpeedLabel.Size = UDim2.new(0.5, 0, 1, 0)
flySpeedLabel.BackgroundTransparency = 1
flySpeedLabel.Text = "‚ö° Velocidade Fly:"
flySpeedLabel.Font = Enum.Font.SourceSansBold
flySpeedLabel.TextSize = 13
flySpeedLabel.TextColor3 = Color3.fromRGB(220, 220, 240)
flySpeedLabel.TextXAlignment = Enum.TextXAlignment.Left
flySpeedLabel.Parent = flySpeedFrame

local flySpeedInput = Instance.new("TextBox")
flySpeedInput.Size = UDim2.new(0.5, -5, 0, 30)
flySpeedInput.Position = UDim2.new(0.5, 5, 0, 2)
flySpeedInput.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
flySpeedInput.TextColor3 = Color3.fromRGB(255, 255, 255)
flySpeedInput.PlaceholderText = "1-100"
flySpeedInput.Text = tostring(FlySystem.speed)
flySpeedInput.Font = Enum.Font.SourceSans
flySpeedInput.TextSize = 14
flySpeedInput.ClearTextOnFocus = false
flySpeedInput.Parent = flySpeedFrame
Instance.new("UICorner", flySpeedInput).CornerRadius = UDim.new(0, 6)

flySpeedInput:GetPropertyChangedSignal("Text"):Connect(function()
	local newSpeed = tonumber(flySpeedInput.Text)
	if newSpeed and newSpeed >= 1 and newSpeed <= 100 then
		FlySystem:setSpeed(newSpeed)
	end
end)

-- Atualizar toggle visual baseado no estado do fly
task.spawn(function()
	while true do
		task.wait(0.1)
		if flyToggle then
			local checkbox = flyToggle:FindFirstChildOfClass("TextButton")
			if checkbox then
				if FlySystem.flying then
					checkbox.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
				else
					checkbox.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
				end
			end
		end
	end
end)

local noclipToggle = createToggle(movementContent, "üîì Noclip - Atravessa Tudo", function(enabled)
	noclip = enabled
end)

-- Sistema Noclip Melhorado - Loop cont√≠nuo para garantir que atravessa TODAS as paredes
task.spawn(function()
	while true do
		task.wait(0.05) -- Verifica√ß√£o frequente
		if noclip then
			local character = LocalPlayer.Character
			if character then
				-- Desabilitar colis√£o em TODAS as partes do personagem
				forEachCharacterPart(character, function(part)
					if part.CanCollide == true then
						part.CanCollide = false
					end
				end)
				-- Tamb√©m desabilitar colis√£o em partes espec√≠ficas que podem ser esquecidas
				local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
				if humanoidRootPart and humanoidRootPart.CanCollide == true then
					humanoidRootPart.CanCollide = false
				end
			end
		end
	end
end)

-- ========= SUBCATEGORIA: BOOSTS =========
local boostsSubCategory = Instance.new("Frame")
boostsSubCategory.Size = UDim2.new(1, -20, 0, 0)
boostsSubCategory.Position = UDim2.new(0, 10, 0, 180)
boostsSubCategory.BackgroundColor3 = Color3.fromRGB(25, 45, 25)
boostsSubCategory.BackgroundTransparency = 0.3
boostsSubCategory.Parent = miscCategory
Instance.new("UICorner", boostsSubCategory).CornerRadius = UDim.new(0, 10)

local boostsTitle = Instance.new("TextLabel")
boostsTitle.Size = UDim2.new(1, -20, 0, 25)
boostsTitle.Position = UDim2.new(0, 10, 0, 5)
boostsTitle.BackgroundTransparency = 1
boostsTitle.Text = "‚ö° BOOSTS (Persistentes)"
boostsTitle.Font = Enum.Font.SourceSansBold
boostsTitle.TextSize = 14
boostsTitle.TextColor3 = Color3.fromRGB(92, 246, 139)
boostsTitle.TextXAlignment = Enum.TextXAlignment.Left
boostsTitle.Parent = boostsSubCategory

local boostsContent = Instance.new("Frame")
boostsContent.Size = UDim2.new(1, -20, 1, -35)
boostsContent.Position = UDim2.new(0, 10, 0, 30)
boostsContent.BackgroundTransparency = 1
boostsContent.Parent = boostsSubCategory

local boostsLayout = Instance.new("UIListLayout")
boostsLayout.Padding = UDim.new(0, 6)
boostsLayout.Parent = boostsContent

local speedToggle = createToggle(boostsContent, "üèÉ Speed Boost", function(enabled)
	speedBoostEnabled = enabled
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if enabled then
				originalWalkSpeed = humanoid.WalkSpeed
				humanoid.WalkSpeed = speedBoostValue
			else
				humanoid.WalkSpeed = originalWalkSpeed
			end
		end
	end
end)

local jumpToggle = createToggle(boostsContent, "ü¶ò Jump Power Boost", function(enabled)
	jumpPowerBoostEnabled = enabled
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if enabled then
				originalJumpPower = humanoid.JumpPower
				humanoid.JumpPower = jumpPowerBoostValue
			else
				humanoid.JumpPower = originalJumpPower
			end
		end
	end
end)

-- Sistema de Persist√™ncia - Reaplicar boosts ap√≥s respawn
LocalPlayer.CharacterAdded:Connect(function(character)
	-- Aguardar o personagem carregar completamente
	task.wait(0.5)

	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if humanoid then
		if speedBoostEnabled then
			humanoid.WalkSpeed = speedBoostValue
		end

		if jumpPowerBoostEnabled then
			humanoid.JumpPower = jumpPowerBoostValue
		end
	end
	
	-- Reaplica ESP para todos os jogadores ap√≥s respawn
	if espEnabled then
		task.wait(1) -- Aguardar mais um pouco para garantir
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and player.Character then
				pcall(function()
					refreshESPForPlayer(player)
				end)
			end
		end
	end
end)

-- Speed Boost Slider
local speedTitle = Instance.new("TextLabel")
speedTitle.BackgroundTransparency = 1
speedTitle.Size = UDim2.new(1, 0, 0, 20)
speedTitle.Font = Enum.Font.SourceSansBold
speedTitle.TextSize = 12
speedTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
speedTitle.Text = "Velocidade: " .. speedBoostValue
speedTitle.Parent = boostsContent

local speedSlider = Instance.new("Frame")
speedSlider.Size = UDim2.new(1, 0, 0, 16) -- AUMENTADO (igual ao Smooth)
speedSlider.BackgroundColor3 = COLOR_SLIDER_TRACK
speedSlider.Parent = boostsContent
Instance.new("UICorner", speedSlider).CornerRadius = UDim.new(0, 5)

local speedFill = Instance.new("Frame")
speedFill.Size = UDim2.fromScale(speedBoostValue / 200, 1)
speedFill.BackgroundColor3 = COLOR_NEON_PINK
speedFill.Parent = speedSlider
Instance.new("UICorner", speedFill).CornerRadius = UDim.new(0, 4)

local speedDragging = false
speedSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		speedDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		speedDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if speedDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = speedSlider.AbsolutePosition
		local sliderSize = speedSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		speedBoostValue = math.floor(0 + relativeX * 200)
		speedTitle.Text = "Velocidade: " .. speedBoostValue
		speedFill.Size = UDim2.fromScale(relativeX, 1)
		if speedBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.WalkSpeed = speedBoostValue
				end
			end
		end
	end
end)

-- Jump Power Slider
local jumpTitle = Instance.new("TextLabel")
jumpTitle.BackgroundTransparency = 1
jumpTitle.Size = UDim2.new(1, 0, 0, 20)
jumpTitle.Font = Enum.Font.SourceSansBold
jumpTitle.TextSize = 12
jumpTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
jumpTitle.Text = "Pulo: " .. jumpPowerBoostValue
jumpTitle.Parent = boostsContent

local jumpSlider = Instance.new("Frame")
jumpSlider.Size = UDim2.new(1, 0, 0, 16) -- AUMENTADO (igual ao Smooth)
jumpSlider.BackgroundColor3 = COLOR_SLIDER_TRACK
jumpSlider.Parent = boostsContent
Instance.new("UICorner", jumpSlider).CornerRadius = UDim.new(0, 5)

local jumpFill = Instance.new("Frame")
jumpFill.Size = UDim2.fromScale(jumpPowerBoostValue / 200, 1)
jumpFill.BackgroundColor3 = COLOR_NEON_PINK
jumpFill.Parent = jumpSlider
Instance.new("UICorner", jumpFill).CornerRadius = UDim.new(0, 4)

local jumpDragging = false
jumpSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		jumpDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		jumpDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if jumpDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = jumpSlider.AbsolutePosition
		local sliderSize = jumpSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		jumpPowerBoostValue = math.floor(0 + relativeX * 200)
		jumpTitle.Text = "Pulo: " .. jumpPowerBoostValue
		jumpFill.Size = UDim2.fromScale(relativeX, 1)
		if jumpPowerBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.JumpPower = jumpPowerBoostValue
				end
			end
		end
	end
end)

-- ========= SUBCATEGORIA: UTILIT√ÅRIOS =========
local utilsSubCategory = Instance.new("Frame")
utilsSubCategory.Size = UDim2.new(1, -20, 0, 0)
utilsSubCategory.Position = UDim2.new(0, 10, 0, 350)
utilsSubCategory.BackgroundColor3 = Color3.fromRGB(45, 25, 25)
utilsSubCategory.BackgroundTransparency = 0.3
utilsSubCategory.Parent = miscCategory
Instance.new("UICorner", utilsSubCategory).CornerRadius = UDim.new(0, 10)

local utilsTitle = Instance.new("TextLabel")
utilsTitle.Size = UDim2.new(1, -20, 0, 25)
utilsTitle.Position = UDim2.new(0, 10, 0, 5)
utilsTitle.BackgroundTransparency = 1
utilsTitle.Text = "üõ†Ô∏è UTILIT√ÅRIOS"
utilsTitle.Font = Enum.Font.SourceSansBold
utilsTitle.TextSize = 14
utilsTitle.TextColor3 = Color3.fromRGB(246, 139, 92)
utilsTitle.TextXAlignment = Enum.TextXAlignment.Left
utilsTitle.Parent = utilsSubCategory

local utilsContent = Instance.new("Frame")
utilsContent.Size = UDim2.new(1, -20, 1, -35)
utilsContent.Position = UDim2.new(0, 10, 0, 30)
utilsContent.BackgroundTransparency = 1
utilsContent.Parent = utilsSubCategory

local utilsLayout = Instance.new("UIListLayout")
utilsLayout.Padding = UDim.new(0, 6)
utilsLayout.Parent = utilsContent

-- Conex√£o do infinite jump
local infiniteJumpConnection = nil

local infiniteJumpToggle = createToggle(utilsContent, "üîÑ Infinite Jump", function(enabled)
	infiniteJumpEnabled = enabled
	if enabled then
		infiniteJumpConnection = UserInputService.JumpRequest:Connect(function()
			if not infiniteJumpEnabled then return end
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end)
	else
		if infiniteJumpConnection then
			infiniteJumpConnection:Disconnect()
			infiniteJumpConnection = nil
		end
	end
end)

local antiKickToggle = createToggle(utilsContent, "üõ°Ô∏è Anti-Kick", function(enabled)
	antiKickEnabled = enabled
	if enabled then
		local mt = getrawmetatable(game)
		local old = mt.__namecall
		setreadonly(mt, false)
		mt.__namecall = newcclosure(function(self, ...)
			local args = {...}
			local method = getnamecallmethod()
			if method == "Kick" then
				return nil
			end
			return old(self, ...)
		end)
		setreadonly(mt, true)
	end
end)

-- TP para Cursor com Bind
local tpToCursorBind = nil
local tpToCursorBindString = "Nenhuma"
local tpCursorCooldown = 0

local tpCursorBindBtn = Instance.new("TextButton")
tpCursorBindBtn.Size = UDim2.new(1, 0, 0, 45)
tpCursorBindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
tpCursorBindBtn.BackgroundTransparency = 0.2
tpCursorBindBtn.Text = "üìç TP Cursor Bind: " .. tpToCursorBindString
tpCursorBindBtn.Font = Enum.Font.SourceSans
tpCursorBindBtn.TextSize = 14
tpCursorBindBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
tpCursorBindBtn.Parent = utilsContent
Instance.new("UICorner", tpCursorBindBtn).CornerRadius = UDim.new(0, 8)

local tpCursorBindListening = false
tpCursorBindBtn.MouseButton1Click:Connect(function()
	tpCursorBindListening = true
	tpCursorBindBtn.Text = "Pressione qualquer tecla..."
	tpCursorBindBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if tpCursorBindListening and not processed and input.UserInputType == Enum.UserInputType.Keyboard then
		tpToCursorBind = input.KeyCode
		tpToCursorBindString = input.KeyCode.Name
		tpCursorBindBtn.Text = "üìç TP Cursor Bind: " .. tpToCursorBindString
		tpCursorBindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
		tpCursorBindListening = false
	end
end)

-- Bind para trocar tecla do menu
local menuBindBtn = Instance.new("TextButton")
menuBindBtn.Size = UDim2.new(1, 0, 0, 45)
menuBindBtn.BackgroundColor3 = SAKURA.surface
menuBindBtn.BackgroundTransparency = 0.2
menuBindBtn.Text = "üîë Menu Bind: M"
menuBindBtn.Font = Enum.Font.Gotham
menuBindBtn.TextSize = 13
menuBindBtn.TextColor3 = SAKURA.text
menuBindBtn.BorderSizePixel = 0
menuBindBtn.Parent = utilsContent
Instance.new("UICorner", menuBindBtn).CornerRadius = UDim.new(0, 8)

local menuBindBorder = Instance.new("UIStroke")
menuBindBorder.Color = SAKURA.border
menuBindBorder.Thickness = 1
menuBindBorder.Transparency = 0.6
menuBindBorder.Parent = menuBindBtn

local menuBindListening = false
menuBindBtn.MouseButton1Click:Connect(function()
	menuBindListening = true
	menuBindBtn.Text = "Press any key..."
	menuBindBtn.BackgroundColor3 = SAKURA.gold
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if menuBindListening and not processed and input.UserInputType == Enum.UserInputType.Keyboard then
		UI_TOGGLE_KEY = input.KeyCode
		menuBindBtn.Text = "üîë Menu Bind: " .. input.KeyCode.Name
		menuBindBtn.BackgroundColor3 = SAKURA.surface
		menuBindListening = false
	end
end)

-- Seletor de tamanho do menu
local menuSizes = {
	{name = "Grande (1100x750)", width = 1100, height = 750},
	{name = "M√©dio (900x600)", width = 900, height = 600}
}
local currentSizeIndex = 1

local menuSizeBtn = Instance.new("TextButton")
menuSizeBtn.Size = UDim2.new(1, 0, 0, 45)
menuSizeBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
menuSizeBtn.BackgroundTransparency = 0.2
menuSizeBtn.Text = "üìê Tamanho: " .. menuSizes[currentSizeIndex].name
menuSizeBtn.Font = Enum.Font.SourceSans
menuSizeBtn.TextSize = 14
menuSizeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
menuSizeBtn.Parent = utilsContent
Instance.new("UICorner", menuSizeBtn).CornerRadius = UDim.new(0, 8)

-- Fun√ß√£o para redimensionar UI proporcionalmente
function resizeUI(newWidth, newHeight)
	-- Centralizar o painel
	mainFrame.Position = UDim2.new(0.5, -newWidth/2, 0.5, -newHeight/2)
	
	-- Ajustar header (altura proporcional)
	local headerRatio = 60 / 750 -- Altura original do header / altura original
	header.Size = UDim2.new(1, 0, 0, math.max(50, newHeight * headerRatio))
	
	-- Ajustar tabs container (altura proporcional)
	local tabsRatio = 50 / 750 -- Altura original dos tabs / altura original
	tabsContainer.Size = UDim2.new(1, -20, 0, math.max(40, newHeight * tabsRatio))
	tabsContainer.Position = UDim2.new(0, 10, 0, header.Size.Y.Offset + 10)
	
	-- Ajustar content area (altura restante)
	local contentY = header.Size.Y.Offset + tabsContainer.Size.Y.Offset + 20
	content.Size = UDim2.new(1, -20, 1, -contentY)
	content.Position = UDim2.new(0, 10, 0, contentY)
	
	-- Ajustar tamanhos de fonte proporcionalmente
	local fontScale = newHeight / 750
	local titleSize = math.max(20, 28 * fontScale)
	local tabSize = math.max(12, 15 * fontScale)
	local buttonSize = math.max(12, 14 * fontScale)
	
	title.TextSize = titleSize
	for _, tab in pairs(tabs) do
		if tab:IsA("TextButton") then
			tab.TextSize = tabSize
		end
	end
	
	-- Ajustar elementos das p√°ginas
	for _, page in pairs(pages) do
		if page:IsA("ScrollingFrame") then
			-- Ajustar elementos dentro das p√°ginas
			for _, child in ipairs(page:GetDescendants()) do
				if child:IsA("TextLabel") or child:IsA("TextButton") then
					child.TextSize = buttonSize
				elseif child:IsA("TextBox") then
					child.TextSize = buttonSize
				end
			end
		end
	end
end

menuSizeBtn.MouseButton1Click:Connect(function()
	currentSizeIndex = currentSizeIndex % #menuSizes + 1
	local size = menuSizes[currentSizeIndex]
	
	-- Redimensionar mainFrame
	mainFrame.Size = UDim2.new(0, size.width, 0, size.height)
	
	-- Aplicar redimensionamento proporcional
	resizeUI(size.width, size.height)
	
	-- Atualizar texto do bot√£o
	menuSizeBtn.Text = "üìê Tamanho: " .. size.name
end)

-- Ajustar tamanhos das subcategorias
movementSubCategory.Size = UDim2.new(1, -20, 0, movementLayout.AbsoluteContentSize.Y + 40)
boostsSubCategory.Size = UDim2.new(1, -20, 0, boostsLayout.AbsoluteContentSize.Y + 40)
utilsSubCategory.Size = UDim2.new(1, -20, 0, utilsLayout.AbsoluteContentSize.Y + 40)



-- Mostrar/ocultar painel Sakura
function showPanel(show)
	if panelVisible == show then return end
	panelVisible = show
	mainFrame.Visible = show

	if show then
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	else
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true
	end
end

-- Fun√ß√£o para criar player buttons
function addPlayerToRow(p)
	if p == LocalPlayer then return end

	local playerBtn = Instance.new("TextButton")
	playerBtn.Name = p.Name
	playerBtn.Size = UDim2.new(1, -8, 0, 40)
	playerBtn.BackgroundColor3 = Color3.fromRGB(36,36,44)
	playerBtn.Text = ""
	playerBtn.Parent = playersList
	Instance.new("UICorner", playerBtn).CornerRadius = UDim.new(0, 6)

	local nameLbl = Instance.new("TextLabel")
	nameLbl.BackgroundTransparency = 1
	nameLbl.Size = UDim2.new(1, -8, 1, 0)
	nameLbl.Position = UDim2.new(0, 8, 0, 0)
	nameLbl.Font = Enum.Font.GothamSemibold
	nameLbl.TextSize = 14
	nameLbl.TextColor3 = Color3.fromRGB(255,255,255)
	nameLbl.TextXAlignment = Enum.TextXAlignment.Left

	nameLbl.Text = p.Name
	nameLbl.Parent = playerBtn

	local selectionIndicator = Instance.new("Frame")
	selectionIndicator.Size = UDim2.new(0, 4, 1, -8)
	selectionIndicator.Position = UDim2.new(0, 2, 0, 4)
	selectionIndicator.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	selectionIndicator.Visible = false
	selectionIndicator.Parent = playerBtn
	Instance.new("UICorner", selectionIndicator).CornerRadius = UDim.new(0, 2)

	playerBtn.MouseButton1Click:Connect(function()
		-- Desselecionar anterior
		for _, btn in ipairs(playersList:GetChildren()) do
			if btn:IsA("TextButton") then
				local indicator = btn:FindFirstChildOfClass("Frame")
				if indicator then
					indicator.Visible = false
					btn.BackgroundColor3 = Color3.fromRGB(36,36,44)
				end
				local lbl = btn:FindFirstChildOfClass("TextLabel")
				if lbl then
					lbl.TextColor3 = Color3.fromRGB(255,255,255) -- Branco
				end
			end
		end

		-- Selecionar atual
		selectionIndicator.Visible = true
		playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
		nameLbl.TextColor3 = Color3.fromRGB(255, 255, 0) -- Amarelo
		selectedPlayer = p

		-- Show actions panel
		actionsPanel.Visible = true
		tpBtn.Visible = true
		spectateBtn.Visible = true
	end)

	return playerBtn
end

function clearPlayersList()
	for _, c in ipairs(playersList:GetChildren()) do
		if c:IsA("TextButton") then c:Destroy() end
	end
end

function rebuildPlayersList()
    if isTypingInSearch then return end
    
    for _, child in ipairs(playersList:GetChildren()) do
        if child:IsA("Frame") or child:IsA("TextButton") then
            child:Destroy()
        end
    end

    playerButtons = {}

    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            pcall(function()
                createPlayerButton(plr)
            end)
        end
    end

    if searchBox and searchBox.Text and searchBox.Text ~= "" then
        applySearch(searchBox.Text)
    end
    
    updatePlayerCounter()
end

Players.PlayerAdded:Connect(function(p)
	rebuildPlayersList()
end)

Players.PlayerRemoving:Connect(function(p)
	if selectedPlayer == p then
		selectedPlayer = nil
	end
	rebuildPlayersList()
end)

function getClosestPlayer()
	if not aimbotEnabled then return nil end

	local closestPlayer = nil
	local closestDistance = aimbotFOV
	local camera = workspace.CurrentCamera
	local centerPos = aimbotMobile and UserInputService:GetMouseLocation() or Vector2.new(camera.ViewportSize.X / 2, camera.ViewportSize.Y / 2)

	for player in pairs(ESPData) do
		if isValidPlayer(player) and isEnemy(player) then
			local character = ESPData[player].character
			
			-- Verificar se est√° na mesma dimens√£o
			if not isInSameDimension(character) then
				continue
			end
			
			local targetPart = (aimbotTarget == "Cabe√ßa") and character:FindFirstChild("Head") or (character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso"))

			if targetPart then
				local screenPos, onScreen = camera:WorldToViewportPoint(targetPart.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - centerPos).Magnitude
					if distance <= closestDistance then
						if aimbotOnlyVisible then
							local highlight = highlights[character]
							if not highlight or highlight.FillColor ~= Color3.fromRGB(0, 255, 0) then
								continue
							end
						end
						closestDistance = distance
						closestPlayer = player
					end
				end
			end
		end
	end

	return closestPlayer
end

-- Aimbot aim function
function aimAt(targetPlayer)
	if not targetPlayer or not targetPlayer.Character then return end

	local camera = workspace.CurrentCamera
	local character = targetPlayer.Character

	local targetPart = nil
	if aimbotTarget == "Cabe√ßa" then
		targetPart = character:FindFirstChild("Head")
	elseif aimbotTarget == "Peito" then
		targetPart = character:FindFirstChild("UpperTorso") or character:FindFirstChild("Torso")
	end

	if not targetPart then return end

	local targetPos = targetPart.Position
	local camPos = camera.CFrame.Position
	local targetCFrame = CFrame.lookAt(camPos, targetPos)

	local smoothFactor = (20 - aimbotSmooth) / 20
	if smoothFactor < 0.05 then smoothFactor = 1 end

	camera.CFrame = camera.CFrame:Lerp(targetCFrame, smoothFactor)
end

-- Fun√ß√£o para verificar se est√° em ve√≠culo em movimento
function isInMovingVehicle()
	local character = LocalPlayer.Character
	if not character then return false end
	
	local humanoid = character:FindFirstChildOfClass("Humanoid")
	if not humanoid then return false end
	
	local seatPart = humanoid.SeatPart
	if not seatPart then return false end
	
	-- Verificar se o ve√≠culo est√° em movimento
	local vehicle = seatPart.Parent
	if vehicle then
		local primaryPart = vehicle.PrimaryPart or vehicle:FindFirstChildWhichIsA("BasePart")
		if primaryPart and primaryPart.AssemblyLinearVelocity.Magnitude > 10 then
			return true
		end
	end
	
	return false
end

-- Aimbot activation - custom bind
local aimbotKeyHeld = false

UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if not aimbotEnabled then return end

	local shouldActivate = false
	if aimbotBindString == "MouseLeft" and input.UserInputType == Enum.UserInputType.MouseButton1 then
		shouldActivate = true
	elseif aimbotBindString == "MouseRight" and input.UserInputType == Enum.UserInputType.MouseButton2 then
		shouldActivate = true
	elseif aimbotBindString == "MouseMiddle" and input.UserInputType == Enum.UserInputType.MouseButton3 then
		shouldActivate = true
	elseif aimbotBindString == "MouseButton4" and input.UserInputType == Enum.UserInputType.MouseButton4 then
		shouldActivate = true
	elseif aimbotBindString == "MouseButton5" and input.UserInputType == Enum.UserInputType.MouseButton5 then
		shouldActivate = true
	elseif input.KeyCode and input.KeyCode.Name == aimbotBindString then
		shouldActivate = true
	end

	if shouldActivate then
		aimbotKeyHeld = true
	end
end)

UserInputService.InputEnded:Connect(function(input, processed)
	if processed then return end

	local shouldDeactivate = false
	if aimbotBindString == "MouseLeft" and input.UserInputType == Enum.UserInputType.MouseButton1 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseRight" and input.UserInputType == Enum.UserInputType.MouseButton2 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseMiddle" and input.UserInputType == Enum.UserInputType.MouseButton3 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseButton4" and input.UserInputType == Enum.UserInputType.MouseButton4 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseButton5" and input.UserInputType == Enum.UserInputType.MouseButton5 then
		shouldDeactivate = true
	elseif input.KeyCode and input.KeyCode.Name == aimbotBindString then
		shouldDeactivate = true
	end

	if shouldDeactivate then
		aimbotKeyHeld = false
	end
end)

-- Aimbot vars
currentAimbotTarget = nil
lastTargetUpdateTime = 0

-- Continuous aiming
RunService.RenderStepped:Connect(function()
	if (aimbotKeyHeld and aimbotEnabled) or isInMovingVehicle() then
		if tick() - lastTargetUpdateTime >= 0.15 then
			if currentAimbotTarget then
				if not currentAimbotTarget.Character or not currentAimbotTarget.Character:FindFirstChildOfClass("Humanoid") or currentAimbotTarget.Character:FindFirstChildOfClass("Humanoid").Health <= 0 then
					currentAimbotTarget = getClosestPlayer()
				end
			else
				currentAimbotTarget = getClosestPlayer()
			end
			lastTargetUpdateTime = tick()
		end
		if currentAimbotTarget then aimAt(currentAimbotTarget) end
	else
		currentAimbotTarget = nil
	end
	
	-- ESP COM LIMPEZA AUTOM√ÅTICA
	if espEnabled then
		local validChars = {}
		
		for _, player in ipairs(Players:GetPlayers()) do
			if player ~= LocalPlayer and isEnemy(player) then -- S√≥ mostrar inimigos
				local character = player.Character
				
				if character then
					local humanoid = character:FindFirstChildOfClass("Humanoid")
					local root = character:FindFirstChild("HumanoidRootPart")
					
					if humanoid and root and humanoid.Health > 0 then
						validChars[character] = true
						
						pcall(function()
							if showSkeleton then ensureHighlight(character) end
							if showBox3D then ensureBox3D(character) end
							if showTracers then ensureTracer(character) end
							if showEspDistance then ensureDistanceLabel(character) end
							if showName then ensureNameLabel(character, player) end
							if showHealth then ensureHealthBar(character) end
						end)
					end
				end
			end
		end
		
		-- LIMPAR ESP de personagens inv√°lidos
		for char, _ in pairs(highlights) do
			if not validChars[char] then
				pcall(function() highlights[char]:Destroy() end)
				highlights[char] = nil
			end
		end
		for char, _ in pairs(boxes) do
			if not validChars[char] then
				pcall(function() boxes[char]:Remove() end)
				boxes[char] = nil
			end
		end
		for char, _ in pairs(nameLabels) do
			if not validChars[char] then
				pcall(function() nameLabels[char]:Remove() end)
				nameLabels[char] = nil
			end
		end
		for char, _ in pairs(distanceLabels) do
			if not validChars[char] then
				pcall(function() distanceLabels[char]:Remove() end)
				distanceLabels[char] = nil
			end
		end
		for char, _ in pairs(tracers) do
			if not validChars[char] then
				pcall(function() tracers[char]:Remove() end)
				tracers[char] = nil
			end
		end
		for char, bar in pairs(healthBars) do
			if not validChars[char] then
				pcall(function()
					if bar.bg then bar.bg:Remove() end
					if bar.fill then bar.fill:Remove() end
				end)
				healthBars[char] = nil
			end
		end
	else
		-- Limpar TUDO quando ESP desativado
		for char, h in pairs(highlights) do pcall(function() h:Destroy() end) end
		for char, b in pairs(boxes) do pcall(function() b:Remove() end) end
		for char, n in pairs(nameLabels) do pcall(function() n:Remove() end) end
		for char, d in pairs(distanceLabels) do pcall(function() d:Remove() end) end
		for char, t in pairs(tracers) do pcall(function() t:Remove() end) end
		for char, bar in pairs(healthBars) do
			pcall(function()
				if bar.bg then bar.bg:Remove() end
				if bar.fill then bar.fill:Remove() end
			end)
		end
		highlights = {}
		boxes = {}
		nameLabels = {}
		distanceLabels = {}
		tracers = {}
		healthBars = {}
	end
end)

-- Sistema de atualiza√ß√£o autom√°tica DESABILITADO para n√£o interferir na pesquisa
-- startRealTimeUpdates()

-- Eventos globais - USA ESPDATA
for _, player in ipairs(Players:GetPlayers()) do
	setupPlayer(player)
end

Players.PlayerAdded:Connect(function(player)
	setupPlayer(player)
	
	if isTypingInSearch then return end
	if player ~= LocalPlayer then
		createPlayerButton(player)
		updatePlayerCounter()
	end
end)

Players.PlayerRemoving:Connect(function(player)
	local character = player.Character
	
	-- Limpar ESP do personagem imediatamente
	if character then
		if highlights[character] then
			pcall(function() highlights[character]:Destroy() end)
			highlights[character] = nil
		end
		if boxes[character] then
			pcall(function() boxes[character]:Remove() end)
			boxes[character] = nil
		end
		if nameLabels[character] then
			pcall(function() nameLabels[character]:Remove() end)
			nameLabels[character] = nil
		end
		if distanceLabels[character] then
			pcall(function() distanceLabels[character]:Remove() end)
			distanceLabels[character] = nil
		end
		if tracers[character] then
			pcall(function() tracers[character]:Remove() end)
			tracers[character] = nil
		end
		if healthBars[character] then
			pcall(function()
				if healthBars[character].bg then healthBars[character].bg:Remove() end
				if healthBars[character].fill then healthBars[character].fill:Remove() end
			end)
			healthBars[character] = nil
		end
	end
	
	if ESPData[player] then
		if ESPData[player].cleanup then
			ESPData[player].cleanup()
		end
		ESPData[player] = nil
	end
	
	if isTypingInSearch then return end
	if playerButtons[player] then
		playerButtons[player]:Destroy()
		playerButtons[player] = nil
	end
	if selectedPlayer == player then
		selectedPlayer = nil
		if actionsPanel then
			actionsPanel.Visible = false
		end
	end
	updatePlayerCounter()
end)



-- Boot
local success, err = pcall(function()
	-- Inicializar lista de players
	for _, plr in ipairs(Players:GetPlayers()) do
		if plr ~= LocalPlayer then
			createPlayerButton(plr)
			if plr.Character then
				refreshESPForPlayer(plr)
			end
		end
	end
	updatePlayerCounter()
end)

if not success then
	warn("‚ùå Erro ao inicializar painel: " .. tostring(err))
end



-- Input geral - Corrigido para evitar conflitos
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end

	-- Menu toggle (M) - Prioridade m√°xima (sempre funciona)
	if input.KeyCode == UI_TOGGLE_KEY then
		showPanel(not panelVisible)
		return
	end

	-- Fly (F) e Destravar Mouse (P) - Funcionam sempre
	if input.KeyCode == FREEFLY_TOGGLE_KEY then
		toggleFly()
	elseif input.KeyCode == UNLOCK_MOUSE_KEY then
		unlockMouse()
	elseif tpToCursorBind and input.KeyCode == tpToCursorBind then
		-- TP para onde o cursor est√° apontando com cooldown e verifica√ß√£o de f√≠sica
		local currentTime = tick()
		if currentTime - tpCursorCooldown < 3 then
			return
		end
		
		local mouse = LocalPlayer:GetMouse()
		local character = LocalPlayer.Character
		if character and mouse.Hit then
			local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
			if humanoidRootPart then
				local targetPos = mouse.Hit.Position + Vector3.new(0, 3, 0)
				
				-- Verificar se h√° parede entre voc√™ e o destino
				local direction = (targetPos - humanoidRootPart.Position)
				local rayParams = RaycastParams.new()
				rayParams.FilterDescendantsInstances = {character}
				rayParams.FilterType = Enum.RaycastFilterType.Blacklist
				
				local rayResult = workspace:Raycast(humanoidRootPart.Position, direction, rayParams)
				
				if rayResult then
					return
				end
				
				-- TP instant√¢neo
				humanoidRootPart.CFrame = CFrame.new(targetPos)
				tpCursorCooldown = currentTime
			end
		end
	end
end)
