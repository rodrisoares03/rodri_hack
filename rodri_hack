-- OneFile_ESP_TP_PRO_Resize_Spectate_Grab_BugarCarro.client.lua
-- Ferramentas locais para o TEU jogo (admin/debug). Sem c√≥digo remoto.

-- ========= Servi√ßos =========
local Players = game:GetService("Players")
local RunService = game:GetService("RunService")
local UserInputService = game:GetService("UserInputService")
local ContextActionService = game:GetService("ContextActionService")
local TweenService = game:GetService("TweenService")
local HttpService = game:GetService("HttpService")
local Lighting = game:GetService("Lighting")

local LocalPlayer = Players.LocalPlayer
local Camera = workspace.CurrentCamera

-- ========= Config =========
local ESP_DEFAULT_ON = false
local SHOW_NAME_DEFAULT = false
local SHOW_HEALTH_DEFAULT = false
local SHOW_DISTANCE_DEFAULT = false
local SHOW_TRACERS_DEFAULT = false
local ESP_POSITION_DEFAULT = "Topo"      -- Topo | Baixo | Lado
local ESP_MODE_DEFAULT = "Cheio"         -- Cheio | Bordas
local TEAM_FILTER_DEFAULT = "Todos"      -- Todos | S√≥ inimigos

local FILL_COLOR = Color3.fromRGB(255, 0, 0)
local OUTLINE_COLOR = Color3.fromRGB(255, 255, 255)
local TRACER_COLOR = Color3.fromRGB(0, 255, 0)

-- ========= Aimbot Config =========
local aimbotEnabled = false
local aimbotFOV = 100
local aimbotFOVZero = 0 -- FOV starting from 0
local aimbotSmooth = 5
local aimbotTarget = "Head" -- Head or Body
local aimbotBind = Enum.KeyCode.Unknown
local aimbotBindString = "None"
local aimbotShowFOV = false
local aimbotShowFOVZero = false
local aimbotOnlyVisible = false
local aimbotOnNPCs = false

local UI_TOGGLE_KEY = Enum.KeyCode.M
local FREEFLY_TOGGLE_KEY = Enum.KeyCode.F
local CANCEL_FLY_KEY = Enum.KeyCode.X
local GRAB_TOGGLE_KEY = Enum.KeyCode.H  -- Tecla H para agarrar/soltar
local UNLOCK_MOUSE_KEY = Enum.KeyCode.P  -- Tecla P para destravar mouse

-- Voo at√© alvo
local FLY_SPEED = 140
local STOP_DISTANCE = 3
local MAX_FLY_TIME = 30

-- Free-Fly manual
local FREEFLY_SPEED = 50
local FREEFLY_SPRINT_MULT = 2
local FREEFLY_VERTICAL_SPEED = 30

-- Limites do painel
local PANEL_MIN = Vector2.new(500, 400)
local PANEL_MAX = Vector2.new(900, 700)

-- ========= Estado =========
local espEnabled = ESP_DEFAULT_ON
local showName = SHOW_NAME_DEFAULT
local showHealth = SHOW_HEALTH_DEFAULT
local showDistance = SHOW_DISTANCE_DEFAULT
local showTracers = SHOW_TRACERS_DEFAULT
local espPosition = ESP_POSITION_DEFAULT
local espMode = ESP_MODE_DEFAULT
local teamFilter = TEAM_FILTER_DEFAULT
local espAutoEnabled = false

-- Additional player enhancements
local speedBoostEnabled = false
local speedBoostValue = 50
local jumpPowerBoostEnabled = false
local jumpPowerBoostValue = 100
local infiniteJumpEnabled = false
local antiKickEnabled = false

-- Original values for restoration
local originalWalkSpeed = 16
local originalJumpPower = 50

local highlights = {}         -- [Character] = Highlight
local overlays = {}           -- [Character] = BillboardGui

-- fly-to target
local flightConn: RBXScriptConnection? = nil
local flightStartTime = 0
local cancelling = false
local noclipActive = false
local savedCollide = {}

-- free-fly manual
local freeflyOn = false
local freeflyConn: RBXScriptConnection? = nil
local inputStates = {W=false,A=false,S=false,D=false,Space=false,Shift=false,Ctrl=false}
local freeflyStartCFrame = nil

-- UI state
local panelVisible = false
local prevMouseBehavior, prevMouseIconEnabled

-- spectate
local spectating: Player? = nil
local savedSubject: Instance? = nil
local savedCamType: Enum.CameraType? = nil

-- grab system
local grabbing = false
local grabbedPlayer: Player? = nil
local grabConn: RBXScriptConnection? = nil
local GRAB_DISTANCE = 3 -- Dist√¢ncia do lado
local GRAB_HEIGHT = 0 -- Altura relativa

-- bugar player system
local buggingPlayers = {} -- Tabela para controlar players sendo bugados
local bugConn: RBXScriptConnection? = nil

-- bugar carro system
local buggingCars = {} -- Tabela para controlar carros sendo bugados
local bugCarConn: RBXScriptConnection? = nil

-- player selection
local selectedPlayer: Player? = nil

-- ========= SISTEMA DE FLY/NOCLIP DO PRIMEIRO MENU =========
local flying = false
local noclip = false
local speed = 1  -- COME√áA COM VELOCIDADE 1
local bodyGyro, bodyVelocity

-- Fun√ß√£o para atualizar o personagem ao respawnar
local function onCharacterAdded(char)
    character = char
    humanoidRootPart = char:WaitForChild("HumanoidRootPart")
    humanoid = char:WaitForChild("Humanoid")

    -- Resetar fly e noclip ao respawnar
    flying = false
    noclip = false

    -- Atualizar bot√µes se existirem
    if flyToggleBtn then
        flyToggleBtn.Text = "Fly: OFF"
        flyToggleBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    end
    if noclipToggleBtn then
        noclipToggleBtn.Text = "Noclip: OFF"
        noclipToggleBtn.BackgroundColor3 = Color3.fromRGB(70, 70, 70)
    end
end

LocalPlayer.CharacterAdded:Connect(onCharacterAdded)

-- Fun√ß√£o de controle Fly
local function toggleFly()
    flying = not flying
    
    if flyToggleBtn then
        flyToggleBtn.Text = flying and "Fly: ON" or "Fly: OFF"
        flyToggleBtn.BackgroundColor3 = flying and Color3.fromRGB(0, 170, 127) or Color3.fromRGB(70, 70, 70)
    end
    
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    local humanoid = character:FindFirstChild("Humanoid")
    if not humanoidRootPart or not humanoid then return end
    
    -- Criar e remover o BodyGyro e BodyVelocity para manter o personagem no ar
    if flying then
        bodyGyro = Instance.new("BodyGyro", humanoidRootPart)
        bodyGyro.MaxTorque = Vector3.new(400000, 400000, 400000)
        bodyGyro.D = 1000
        bodyGyro.CFrame = humanoidRootPart.CFrame

        bodyVelocity = Instance.new("BodyVelocity", humanoidRootPart)
        bodyVelocity.MaxForce = Vector3.new(400000, 400000, 400000)
        bodyVelocity.Velocity = Vector3.new(0, 0, 0) -- Garante que ele n√£o cai

    else
        if bodyGyro then bodyGyro:Destroy() end
        if bodyVelocity then bodyVelocity:Destroy() end
    end
end

-- Fun√ß√£o de controle Noclip
local function toggleNoclip()
    noclip = not noclip
    
    if noclipToggleBtn then
        noclipToggleBtn.Text = noclip and "Noclip: ON" or "Noclip: OFF"
        noclipToggleBtn.BackgroundColor3 = noclip and Color3.fromRGB(0, 170, 127) or Color3.fromRGB(70, 70, 70)
    end
end

-- Controles de movimento do sistema fly
local control = {F = 0, B = 0, L = 0, R = 0, U = 0, D = 0}

UserInputService.InputBegan:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.W then control.F = 1 end
    if input.KeyCode == Enum.KeyCode.S then control.B = 1 end
    if input.KeyCode == Enum.KeyCode.A then control.L = 1 end
    if input.KeyCode == Enum.KeyCode.D then control.R = 1 end
    if input.KeyCode == Enum.KeyCode.Space then control.U = 1 end
    if input.KeyCode == Enum.KeyCode.LeftControl then control.D = 1 end
end)

UserInputService.InputEnded:Connect(function(input, gpe)
    if gpe then return end
    if input.KeyCode == Enum.KeyCode.W then control.F = 0 end
    if input.KeyCode == Enum.KeyCode.S then control.B = 0 end
    if input.KeyCode == Enum.KeyCode.A then control.L = 0 end
    if input.KeyCode == Enum.KeyCode.D then control.R = 0 end
    if input.KeyCode == Enum.KeyCode.Space then control.U = 0 end
    if input.KeyCode == Enum.KeyCode.LeftControl then control.D = 0 end
end)

-- Loop principal do sistema fly/noclip
RunService.RenderStepped:Connect(function()
    local character = LocalPlayer.Character
    if not character then return end
    
    local humanoidRootPart = character:FindFirstChild("HumanoidRootPart")
    if not humanoidRootPart then return end

    -- Noclip - COME√áA AQUI NO 1
    if noclip then
        for _, v in pairs(character:GetDescendants()) do
            if v:IsA("BasePart") and v.CanCollide == true then
                v.CanCollide = false
            end
        end
    end

    -- Fly
    if flying then
        local cam = workspace.CurrentCamera
        local moveVec = Vector3.zero

        local forward = cam.CFrame.LookVector
        local right = cam.CFrame.RightVector
        local up = Vector3.new(0, 1, 0)

        moveVec = moveVec 
            + forward * (control.F - control.B)
            + right * (control.R - control.L)
            + up * (control.U - control.D)

        if moveVec.Magnitude > 0 then
            moveVec = moveVec.Unit * speed
            humanoidRootPart.CFrame = humanoidRootPart.CFrame + moveVec
        end
    end
end)

-- ========= Fun√ß√£o para Destravar Mouse =========
local function unlockMouse()
	-- For√ßar o mouse a voltar ao normal
	UserInputService.MouseBehavior = Enum.MouseBehavior.Default
	UserInputService.MouseIconEnabled = true
	
	-- Mostrar mensagem de confirma√ß√£o
	print("üîì Mouse destravado! (Tecla P)")
	
	-- Criar notifica√ß√£o visual tempor√°ria
	local playerGui = LocalPlayer:WaitForChild("PlayerGui")
	local notification = Instance.new("ScreenGui")
	notification.Name = "MouseUnlockNotification"
	notification.ResetOnSpawn = false
	notification.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
	notification.Parent = playerGui
	
	local frame = Instance.new("Frame")
	frame.Size = UDim2.new(0, 300, 0, 80)
	frame.Position = UDim2.new(0.5, -150, 0.1, 0)
	frame.BackgroundColor3 = Color3.fromRGB(0, 100, 0)
	frame.BorderSizePixel = 0
	frame.Parent = notification
	Instance.new("UICorner", frame).CornerRadius = UDim.new(0, 10)
	
	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, 0, 1, 0)
	label.BackgroundTransparency = 1
	label.Text = "üîì MOUSE DESTRAVADO!\nTecla P pressionada"
	label.TextColor3 = Color3.new(1, 1, 1)
	label.Font = Enum.Font.GothamBold
	label.TextSize = 16
	label.TextWrapped = true
	label.Parent = frame
	
	-- Remover ap√≥s 3 segundos
	task.delay(3, function()
		notification:Destroy()
	end)
end

-- ========= Helpers =========
local function getPrimaryPart(char: Model?): BasePart?
	if not char then return nil end
	return char.PrimaryPart
		or char:FindFirstChild("HumanoidRootPart")
		or char:FindFirstChild("Torso")
		or char:FindFirstChild("UpperTorso")
end

local function getHead(char: Model?): BasePart?
	if not char then return nil end
	return char:FindFirstChild("Head") or getPrimaryPart(char)
end

local function forEachCharacterPart(char: Model, fn)
	for _, d in ipairs(char:GetDescendants()) do
		if d:IsA("BasePart") then fn(d) end
	end
end

local function isEnemy(p: Player): boolean
	if not LocalPlayer.Team or not p.Team then return false end
	return p.Team ~= LocalPlayer.Team
end

-- ========= ESP =========
local function applyHighlightMode(h: Highlight)
	if espMode == "Cheio" then
		h.FillTransparency = 0.3
		h.OutlineTransparency = 0
	else
		h.FillTransparency = 1
		h.OutlineTransparency = 0
	end
end

local function ensureHighlight(character: Model)
	if not character or not character.Parent then return end
	local h = highlights[character]
	if not h or not h.Parent then
		h = Instance.new("Highlight")
		h.Name = "PlayerESP"
		h.DepthMode = Enum.HighlightDepthMode.AlwaysOnTop
		h.Adornee = character
		h.Parent = LocalPlayer:WaitForChild("PlayerGui")
		highlights[character] = h
	end
	
	-- Check visibility
	local camera = workspace.CurrentCamera
	local visible = true
	if camera then
		local targetRoot = getPrimaryPart(character)
		local myChar = LocalPlayer.Character
		if targetRoot and myChar then
			local myRoot = getPrimaryPart(myChar)
			if myRoot then
				-- Use character position for raycast to avoid first person issues
				local direction = (targetRoot.Position - myRoot.Position).Unit
				local distance = (targetRoot.Position - myRoot.Position).Magnitude
				local raycastResult = workspace:Raycast(myRoot.Position + Vector3.new(0, 2, 0), direction * distance)
				if raycastResult and raycastResult.Instance and not raycastResult.Instance:IsDescendantOf(character) then
					visible = false
				end
			end
		end
	end
	
	if espAutoEnabled then
		h.FillColor = visible and Color3.fromRGB(0, 255, 0) or Color3.fromRGB(255, 0, 0) -- Green if visible, red if not
	else
		h.FillColor = FILL_COLOR
	end
	h.OutlineColor = OUTLINE_COLOR
	applyHighlightMode(h)
	h.Enabled = espEnabled
end

local function ensureOverlayFor(p: Player, character: Model)
	if not character or not character.Parent then return end
	local bb = overlays[character]
	if not bb or not bb.Parent then
		local head = getHead(character); if not head then return end
		bb = Instance.new("BillboardGui")
		bb.Name = "ESP_Overlay"
		bb.Adornee = head
		bb.Size = UDim2.fromOffset(220, 36)
		bb.AlwaysOnTop = true
		bb.MaxDistance = 10000
		bb.Parent = LocalPlayer:WaitForChild("PlayerGui")

		local holder = Instance.new("Frame")
		holder.Name = "Holder"
		holder.BackgroundTransparency = 1 -- Fundo transparente
		holder.Size = UDim2.fromScale(1, 1)
		holder.Parent = bb

		local label = Instance.new("TextLabel")
		label.Name = "Text"
		label.BackgroundTransparency = 1 -- Fundo transparente
		label.Size = UDim2.fromScale(1, 1)
		label.Font = Enum.Font.GothamBold
		label.TextSize = 14
		label.TextColor3 = Color3.fromRGB(255,255,255)
		label.TextStrokeTransparency = 0.8 -- Contorno para melhor visibilidade
		label.TextStrokeColor3 = Color3.fromRGB(0,0,0)
		label.TextWrapped = true
		label.Text = ""
		label.Parent = holder

		overlays[character] = bb

		character.AncestryChanged:Connect(function(_, parent)
			if not parent then
				if overlays[character] then pcall(function() overlays[character]:Destroy() end) end
				overlays[character] = nil
				if highlights[character] then pcall(function() highlights[character]:Destroy() end) end
				highlights[character] = nil
			end
		end)
	end
end

local function overlayOffsetFor(positionName: string): Vector3
	if positionName == "Topo" then
		return Vector3.new(0, 2.6, 0)
	elseif positionName == "Baixo" then
		return Vector3.new(0, -2.0, 0)
	else
		return Vector3.new(2.5, 1.2, 0) -- direita
	end
end

local function updateOverlay(p: Player, character: Model, bb: BillboardGui)
	if not bb then return end
	local head = getHead(character); if not head then return end
	bb.Adornee = head
	bb.StudsOffsetWorldSpace = overlayOffsetFor(espPosition)

	local bits = {}
	if showName then table.insert(bits, (p.DisplayName or p.Name)) end
	if showHealth then
		local hum = character:FindFirstChildOfClass("Humanoid"); if hum then table.insert(bits, ("HP: %d"):format(hum.Health + 0.5)) end
	end
	local label = bb:FindFirstChild("Holder") and bb.Holder:FindFirstChild("Text")
	if label and label:IsA("TextLabel") then label.Text = table.concat(bits, " | ") end

	local visibleByFilter = true
	if teamFilter == "S√≥ inimigos" then visibleByFilter = isEnemy(p) end

	local h = highlights[character]
	if h then
		h.FillColor = FILL_COLOR
		h.OutlineColor = OUTLINE_COLOR
		applyHighlightMode(h)
		h.Enabled = espEnabled and visibleByFilter
	end
	bb.Enabled = espEnabled and (showName or showHealth) and visibleByFilter
end

local function refreshESPForPlayer(p: Player)
	if p == LocalPlayer then return end
	local char = p.Character; if not char then return end
	if espEnabled then
		ensureHighlight(char)
		ensureOverlayFor(p, char)
		updateOverlay(p, char, overlays[char])
	else
		if overlays[char] then overlays[char].Enabled = false end
		if highlights[char] then highlights[char].Enabled = false end
	end
end

-- Inicial + eventos de players
for _, plr in ipairs(Players:GetPlayers()) do
	if plr ~= LocalPlayer and plr.Character then refreshESPForPlayer(plr) end
	plr.CharacterAdded:Connect(function() 
		task.wait(0.5) -- Esperar mais tempo para garantir que o personagem est√° totalmente carregado
		refreshESPForPlayer(plr) 
	end)
	plr:GetPropertyChangedSignal("Team"):Connect(function() if plr ~= LocalPlayer then refreshESPForPlayer(plr) end end)
end
Players.PlayerAdded:Connect(function(plr)
	if plr ~= LocalPlayer then
		plr.CharacterAdded:Connect(function() 
			task.wait(0.5)
			refreshESPForPlayer(plr) 
		end)
		plr:GetPropertyChangedSignal("Team"):Connect(function() refreshESPForPlayer(plr) end)
	end
end)
Players.PlayerRemoving:Connect(function(plr)
	local char = plr.Character
	if char then
		if overlays[char] then pcall(function() overlays[char]:Destroy() end) end
		overlays[char] = nil
		if highlights[char] then pcall(function() highlights[char]:Destroy() end) end
		highlights[char] = nil
	end
end)

-- Atualiza√ß√£o peri√≥dica (vida/nome/filtro/ESP)
task.spawn(function()
	while true do
		for _, p in ipairs(Players:GetPlayers()) do
			if p ~= LocalPlayer and p.Character then
				local bb = overlays[p.Character]
				if bb then updateOverlay(p, p.Character, bb) end
				-- Update ESP visibility
				if espEnabled then
					local char = p.Character
					if char then
						ensureHighlight(char)
					end
				end
			end
		end
		task.wait(0.1)
	end
end)

-- Atualiza√ß√£o da lista de jogadores automaticamente
task.spawn(function()
	while true do
		task.wait(1)
		rebuildPlayersList()
	end
end)

-- ========= Sistema de Agarrar (Grab) - Lado aleat√≥rio =========
local function stopGrab()
	if grabConn then 
		grabConn:Disconnect() 
		grabConn = nil 
	end
	grabbing = false
	
	if grabbedPlayer then
		local char = grabbedPlayer.Character
		if char then
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum then
				hum.PlatformStand = false
				pcall(function() hum:ChangeState(Enum.HumanoidStateType.Running) end)
			end
		end
		grabbedPlayer = nil
	end
end

local function startGrab(targetPlayer: Player)
	stopGrab()
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	
	local targetChar = targetPlayer.Character
	local myChar = LocalPlayer.Character
	if not targetChar or not myChar then return end
	
	local targetRoot = getPrimaryPart(targetChar)
	local myRoot = getPrimaryPart(myChar)
	if not targetRoot or not myRoot then return end
	
	-- Lado aleat√≥rio (direita ou esquerda)
	local randomSide = math.random(1, 2) == 1 and "Right" or "Left"
	
	-- Ativar noclip no player agarrado
	local targetHum = targetChar:FindFirstChildOfClass("Humanoid")
	if targetHum then
		targetHum.PlatformStand = true
		pcall(function() targetHum:ChangeState(Enum.HumanoidStateType.Physics) end)
	end
	
	grabbing = true
	grabbedPlayer = targetPlayer
	
	grabConn = RunService.Heartbeat:Connect(function(dt)
		if not grabbing or not targetPlayer.Parent then 
			stopGrab()
			return 
		end
		
		targetChar = targetPlayer.Character
		myChar = LocalPlayer.Character
		if not targetChar or not myChar then 
			stopGrab()
			return 
		end
		
		targetRoot = getPrimaryPart(targetChar) or targetRoot
		myRoot = getPrimaryPart(myChar) or myRoot
		if not targetRoot or not myRoot then 
			stopGrab()
			return 
		end
		
		-- Calcular posi√ß√£o ao lado do personagem
		local myCFrame = myRoot.CFrame
		local sideOffset = randomSide == "Right" and myCFrame.RightVector * GRAB_DISTANCE or myCFrame.RightVector * -GRAB_DISTANCE
		local grabPos = myCFrame.Position + sideOffset + Vector3.new(0, GRAB_HEIGHT, 0)
		
		-- Mover player agarrado colado ao lado
		targetChar:PivotTo(CFrame.new(grabPos))
	end)
end

-- ========= Sistema de Bugar Player =========
local function stopBugPlayer(targetPlayer: Player)
	if buggingPlayers[targetPlayer] then
		buggingPlayers[targetPlayer] = nil
	end
	
	-- Parar conex√£o se n√£o h√° mais players sendo bugados
	local hasBuggingPlayers = false
	for _ in pairs(buggingPlayers) do
		hasBuggingPlayers = true
		break
	end
	
	if not hasBuggingPlayers and bugConn then
		bugConn:Disconnect()
		bugConn = nil
	end
end

local function stopAllBugging()
	buggingPlayers = {}
	if bugConn then
		bugConn:Disconnect()
		bugConn = nil
	end
end

local function createExplosion(position)
	-- Criar part√≠cula de explos√£o
	local explosion = Instance.new("Part")
	explosion.Name = "ExplosionEffect"
	explosion.Size = Vector3.new(5, 5, 5)
	explosion.Position = position
	explosion.Anchored = true
	explosion.CanCollide = false
	explosion.Material = Enum.Material.Neon
	explosion.BrickColor = BrickColor.new("Bright orange")
	explosion.Parent = workspace
	
	-- Luz da explos√£o
	local light = Instance.new("PointLight")
	light.Brightness = 10
	light.Range = 20
	light.Color = Color3.new(1, 0.3, 0)
	light.Parent = explosion
	
	-- Efeito de fuma√ßa
	local smoke = Instance.new("Smoke")
	smoke.Size = 0.5
	smoke.Opacity = 0.8
	smoke.RiseVelocity = 10
	smoke.Color = Color3.new(0.3, 0.3, 0.3)
	smoke.Parent = explosion
	
	-- Remover ap√≥s 2 segundos
	task.delay(2, function()
		if explosion and explosion.Parent then
			explosion:Destroy()
		end
	end)
	
	return explosion
end

local function startBugPlayer(targetPlayer: Player)
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	
	-- Adicionar √† lista de players sendo bugados
	buggingPlayers[targetPlayer] = true
	
	-- Iniciar loop de bug se n√£o estiver ativo
	if not bugConn then
		bugConn = RunService.Heartbeat:Connect(function(dt)
			for player, _ in pairs(buggingPlayers) do
				if player and player.Parent then
					local targetChar = player.Character
					if targetChar then
						local targetRoot = getPrimaryPart(targetChar)
						if targetRoot then
							-- Criar explos√µes ao redor do player
							for i = 1, 3 do
								local explosionPos = targetRoot.Position + Vector3.new(
									math.random(-10, 10),
									math.random(0, 5),
									math.random(-10, 10)
								)
								createExplosion(explosionPos)
							end
							
							-- TP instant√¢neo para posi√ß√µes aleat√≥rias (mais agressivo)
							local randomPos = targetRoot.Position + Vector3.new(
								math.random(-15, 15),
								math.random(0, 10),
								math.random(-15, 15)
							)
							targetChar:PivotTo(CFrame.new(randomPos))
							
							-- Efeito de tela tremendo para o player local
							if player == LocalPlayer then
								Camera.CFrame = Camera.CFrame * CFrame.Angles(
									math.rad(math.random(-5, 5)),
									math.rad(math.random(-5, 5)),
									math.rad(math.random(-5, 5))
								)
							end
						end
					end
				else
					-- Remover player se n√£o existir mais
					buggingPlayers[player] = nil
				end
			end
			
			-- Parar conex√£o se n√£o h√° mais players
			local hasPlayers = false
			for _ in pairs(buggingPlayers) do
				hasPlayers = true
				break
			end
			
			if not hasPlayers then
				bugConn:Disconnect()
				bugConn = nil
			end
		end)
	end
end

-- ========= Sistema de Bugar Carro =========
local function stopBugCar(vehicle)
	if buggingCars[vehicle] then
		buggingCars[vehicle] = nil
	end
	
	-- Parar conex√£o se n√£o h√° mais carros sendo bugados
	local hasBuggingCars = false
	for _ in pairs(buggingCars) do
		hasBuggingCars = true
		break
	end
	
	if not hasBuggingCars and bugCarConn then
		bugCarConn:Disconnect()
		bugCarConn = nil
	end
end

local function stopAllBugCars()
	buggingCars = {}
	if bugCarConn then
		bugCarConn:Disconnect()
		bugCarConn = nil
	end
end

local function startBugCar(vehicle)
	if not vehicle then return end
	
	-- Adicionar √† lista de carros sendo bugados
	buggingCars[vehicle] = true
	
	-- Ativar noclip no carro
	forEachCharacterPart(vehicle, function(part)
		part.CanCollide = false
	end)
	
	-- Iniciar loop de bug de carro se n√£o estiver ativo
	if not bugCarConn then
		bugCarConn = RunService.Heartbeat:Connect(function(dt)
			for car, _ in pairs(buggingCars) do
				if car and car.Parent then
					local carRoot = getPrimaryPart(car)
					if carRoot then
						-- Criar explos√µes ao redor do carro
						for i = 1, 2 do
							local explosionPos = carRoot.Position + Vector3.new(
								math.random(-8, 8),
								math.random(0, 3),
								math.random(-8, 8)
							)
							createExplosion(explosionPos)
						end
						
						-- Aplicar for√ßas aleat√≥rias no carro
						local bodyVelocity = Instance.new("BodyVelocity")
						bodyVelocity.Velocity = Vector3.new(
							math.random(-100, 100),
							math.random(50, 150),
							math.random(-100, 100)
						)
						bodyVelocity.MaxForce = Vector3.new(10000, 10000, 10000)
						bodyVelocity.Parent = carRoot
						
						-- TP instant√¢neo para posi√ß√µes aleat√≥rias
						local randomPos = carRoot.Position + Vector3.new(
							math.random(-20, 20),
							math.random(5, 15),
							math.random(-20, 20)
						)
						car:PivotTo(CFrame.new(randomPos))
						
						-- Girar o carro aleatoriamente
						local randomRotation = CFrame.Angles(
							math.rad(math.random(0, 360)),
							math.rad(math.random(0, 360)),
							math.rad(math.random(0, 360))
						)
						car:PivotTo(carRoot.CFrame * randomRotation)
						
						-- Remover a for√ßa ap√≥s um tempo
						task.delay(0.5, function()
							if bodyVelocity and bodyVelocity.Parent then
								bodyVelocity:Destroy()
							end
						end)
					end
				else
					-- Remover carro se n√£o existir mais
					buggingCars[car] = nil
				end
			end
			
			-- Parar conex√£o se n√£o h√° mais carros
			local hasCars = false
			for _ in pairs(buggingCars) do
				hasCars = true
				break
			end
			
			if not hasCars then
				bugCarConn:Disconnect()
				bugCarConn = nil
			end
		end)
	end
end

-- Fun√ß√£o para encontrar carros pr√≥ximos
local function findNearbyCars()
	local cars = {}
	local myChar = LocalPlayer.Character
	if not myChar then return cars end
	
	local myRoot = getPrimaryPart(myChar)
	if not myRoot then return cars end
	
	-- Procurar por ve√≠culos no workspace
	for _, obj in ipairs(workspace:GetDescendants()) do
		if obj:IsA("Model") and (obj:FindFirstChild("DriveSeat") or obj:FindFirstChild("Seat") or obj.Name:lower():find("car") or obj.Name:lower():find("vehicle")) then
			local carRoot = getPrimaryPart(obj)
			if carRoot and (carRoot.Position - myRoot.Position).Magnitude < 50 then
				table.insert(cars, obj)
			end
		end
	end
	
	return cars
end

-- Fun√ß√£o para agarrar player mais pr√≥ximo com tecla H
local function grabNearestPlayer()
	if grabbing then
		stopGrab()
		return
	end
	
	local myChar = LocalPlayer.Character
	if not myChar then return end
	
	local myRoot = getPrimaryPart(myChar)
	if not myRoot then return end
	
	local nearestPlayer = nil
	local nearestDistance = 15 -- Dist√¢ncia m√°xima para agarrar
	
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local targetRoot = getPrimaryPart(player.Character)
			if targetRoot then
				local distance = (targetRoot.Position - myRoot.Position).Magnitude
				if distance <= nearestDistance then
					nearestDistance = distance
					nearestPlayer = player
				end
			end
		end
	end
	
	if nearestPlayer then
		startGrab(nearestPlayer)
	end
end

-- ========= Voo noclip at√© alvo =========
local function stopFlight()
	if flightConn then flightConn:Disconnect() flightConn = nil end
	cancelling = false
end

local function startFlyNoclipTo(targetPlayer: Player)
	stopFlight()
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	local char = LocalPlayer.Character
	local targetChar = targetPlayer.Character
	if not char or not targetChar then return end

	local srcPart = getPrimaryPart(char)
	local dstPart = getPrimaryPart(targetChar)
	if not srcPart or not dstPart then return end

	flightStartTime = time()
	flightConn = RunService.Heartbeat:Connect(function(dt)
		if cancelling then stopFlight() return end
		if not targetPlayer.Parent then stopFlight() return end
		targetChar = targetPlayer.Character; char = LocalPlayer.Character
		if not targetChar or not char then stopFlight() return end
		srcPart = getPrimaryPart(char) or srcPart
		dstPart = getPrimaryPart(targetChar) or dstPart
		if not srcPart or not dstPart then stopFlight() return end

		local src = srcPart.Position
		local dst = dstPart.Position + Vector3.new(0,3,0)
		local dir = (dst - src)
		local dist = dir.Magnitude
		if dist <= STOP_DISTANCE then stopFlight() return end
		if time() - flightStartTime > MAX_FLY_TIME then stopFlight() return end

		local step = math.min(FLY_SPEED * dt, dist)
		local newPos = src + dir.Unit * step
		char:PivotTo(CFrame.new(newPos, dst))
	end)
end

local function instantTPTo(targetPlayer: Player)
	stopFlight()
	if not targetPlayer or targetPlayer == LocalPlayer then return end
	local char = LocalPlayer.Character
	local targetChar = targetPlayer.Character
	if not char or not targetChar then return end
	local srcPart = getPrimaryPart(char)
	local dstPart = getPrimaryPart(targetChar)
	if not srcPart or not dstPart then return end
	local offset = Vector3.new(0,3,0)
	char:PivotTo(CFrame.new(dstPart.Position + offset, dstPart.Position + offset + dstPart.CFrame.LookVector))
end

-- ========= Spectate (c√¢mara) =========
local function startSpectate(p: Player)
	if not p or p == LocalPlayer then return end
	local targetChar = p.Character
	if not targetChar then return end
	local hum = targetChar:FindFirstChildOfClass("Humanoid")
	if not hum then return end

	if not savedSubject then savedSubject = Camera.CameraSubject end
	if not savedCamType then savedCamType = Camera.CameraType end

	Camera.CameraType = Enum.CameraType.Custom
	Camera.CameraSubject = hum
	spectating = p
end

local function stopSpectate()
	if savedSubject then Camera.CameraSubject = savedSubject end
	if savedCamType then Camera.CameraType = savedCamType end
	spectating = nil
end

-- Se o espectado respawnar, mant√©m
Players.PlayerAdded:Connect(function(p)
	if p == spectating then
		p.CharacterAdded:Connect(function(char)
			task.wait(0.1)
			local hum = char:FindFirstChildOfClass("Humanoid")
			if hum and spectating == p then
				Camera.CameraSubject = hum
			end
		end)
	end
end)

-- ========= UI =========
local playerGui = LocalPlayer:WaitForChild("PlayerGui")
local gui = Instance.new("ScreenGui")
gui.Name = "AdminPanel"
gui.ResetOnSpawn = false
gui.ZIndexBehavior = Enum.ZIndexBehavior.Sibling
gui.Parent = playerGui

-- Main Frame
local mainFrame = Instance.new("Frame")
mainFrame.Name = "MainFrame"
mainFrame.Size = UDim2.new(0, 950, 0, 620)
mainFrame.Position = UDim2.new(0.5, -475, 0.5, -310)
mainFrame.BackgroundColor3 = Color3.fromRGB(10, 12, 28)
mainFrame.BorderSizePixel = 0
mainFrame.Parent = gui

-- Add gradient background
local bgGradient = Instance.new("UIGradient")
bgGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(10, 12, 28)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(15, 10, 35))
}
bgGradient.Parent = mainFrame

-- Add border glow
local border = Instance.new("UIStroke")
border.Color = Color3.fromRGB(147, 51, 234)
border.Thickness = 2
border.Transparency = 0.3
border.Parent = mainFrame

local corner = Instance.new("UICorner")
corner.CornerRadius = UDim.new(0, 18)
corner.Parent = mainFrame

-- Header
local header = Instance.new("Frame")
header.Size = UDim2.new(1, 0, 0, 70)
header.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
header.Parent = mainFrame

local headerGradient = Instance.new("UIGradient")
headerGradient.Color = ColorSequence.new{
    ColorSequenceKeypoint.new(0, Color3.fromRGB(139, 92, 246)),
    ColorSequenceKeypoint.new(1, Color3.fromRGB(236, 72, 153))
}
headerGradient.Parent = header

local title = Instance.new("TextLabel")
title.Size = UDim2.new(0.7, 0, 1, 0)
title.Position = UDim2.new(0, 30, 0, 0)
title.BackgroundTransparency = 1
title.Text = "RODRI <font color='#a78bfa'>MENU</font>"
title.Font = Enum.Font.SourceSansBold
title.TextSize = 32
title.TextColor3 = Color3.fromRGB(255, 255, 255)
title.TextXAlignment = Enum.TextXAlignment.Left
title.RichText = true
title.Parent = header

local closeBtn = Instance.new("TextButton")
closeBtn.Size = UDim2.new(0, 36, 0, 36)
closeBtn.Position = UDim2.new(1, -50, 0.5, -18)
closeBtn.BackgroundTransparency = 1
closeBtn.Text = "√ó"
closeBtn.Font = Enum.Font.SourceSansBold
closeBtn.TextSize = 36
closeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
closeBtn.Parent = header

closeBtn.MouseButton1Click:Connect(function()
	showPanel(false)
end)

-- Tabs Container
local tabsContainer = Instance.new("Frame")
tabsContainer.Size = UDim2.new(1, 0, 0, 40)
tabsContainer.Position = UDim2.new(0, 0, 0, 70)
tabsContainer.BackgroundColor3 = Color3.fromRGB(20, 20, 50)
tabsContainer.BackgroundTransparency = 0.4
tabsContainer.Parent = mainFrame

-- Tabs
local tabs = {}
local currentTab = "PLAYERS"

local function createTab(name, text, pos)
	local tab = Instance.new("TextButton")
	tab.Size = UDim2.new(0, 200, 0, 40)
	tab.Position = UDim2.new(0, pos, 0, 0)
	tab.BackgroundTransparency = 1
	tab.Text = text
	tab.Font = Enum.Font.SourceSansBold
	tab.TextSize = 16
	tab.TextColor3 = Color3.fromRGB(255, 255, 255)
	tab.Parent = tabsContainer

	local tabCorner = Instance.new("UICorner")
	tabCorner.CornerRadius = UDim.new(0, 8)
	tabCorner.Parent = tab

	tabs[name] = tab

	tab.MouseButton1Click:Connect(function()
		setTab(name)
	end)

	return tab
end

local tabPlayers = createTab("PLAYERS", "JOGADORES", 50)
local tabESP = createTab("ESP", "VISUAL", 260)
local tabAimbot = createTab("AIMBOT", "RAGE", 470)
local tabUtil = createTab("UTIL", "MISC", 680)

-- Content Area
local content = Instance.new("Frame")
content.Size = UDim2.new(1, 0, 1, -110)
content.Position = UDim2.new(0, 0, 0, 110)
content.BackgroundTransparency = 1
content.Parent = mainFrame

-- Pages
local pages = {}

local function createPage(name)
	local page = Instance.new("ScrollingFrame")
	page.Size = UDim2.new(1, 0, 1, 0)
	page.BackgroundTransparency = 1
	page.ScrollBarThickness = 8
	page.ScrollBarImageColor3 = Color3.fromRGB(139, 92, 246)
	page.Visible = false
	page.Parent = content

	local layout = Instance.new("UIListLayout")
	layout.Padding = UDim.new(0, 15)
	layout.Parent = page

	pages[name] = page
	return page
end

local playersPage = createPage("PLAYERS")
local espPage = createPage("ESP")
local aimbotPage = createPage("AIMBOT")
local utilPage = createPage("UTIL")

-- Set initial tab
local function setTab(tabName)
	for name, tab in pairs(tabs) do
		if name == tabName then
			tab.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
			tab.BackgroundTransparency = 0
			pages[name].Visible = true
			currentTab = name
		else
			tab.BackgroundTransparency = 1
			pages[name].Visible = false
		end
	end
end

setTab("PLAYERS")

-- Create categories and elements
local function createCategory(parent, title)
	local category = Instance.new("Frame")
	category.Size = UDim2.new(1, -40, 0, 0)
	category.Position = UDim2.new(0, 20, 0, 0)
	category.BackgroundColor3 = Color3.fromRGB(30, 30, 70)
	category.BackgroundTransparency = 0.4
	category.BorderSizePixel = 0
	category.Parent = parent

	local categoryCorner = Instance.new("UICorner")
	categoryCorner.CornerRadius = UDim.new(0, 12)
	categoryCorner.Parent = category

	local titleLabel = Instance.new("TextLabel")
	titleLabel.Size = UDim2.new(1, -20, 0, 30)
	titleLabel.Position = UDim2.new(0, 10, 0, 10)
	titleLabel.BackgroundTransparency = 1
	titleLabel.Text = title
	titleLabel.Font = Enum.Font.SourceSansBold
	titleLabel.TextSize = 18
	titleLabel.TextColor3 = Color3.fromRGB(196, 181, 253)
	titleLabel.TextXAlignment = Enum.TextXAlignment.Left
	titleLabel.Parent = category

	local contentFrame = Instance.new("Frame")
	contentFrame.Size = UDim2.new(1, -20, 1, -40)
	contentFrame.Position = UDim2.new(0, 10, 0, 40)
	contentFrame.BackgroundTransparency = 1
	contentFrame.Parent = category

	local contentLayout = Instance.new("UIListLayout")
	contentLayout.Padding = UDim.new(0, 8)
	contentLayout.Parent = contentFrame

	-- Auto-resize category
	local function updateSize()
		local contentSize = contentLayout.AbsoluteContentSize
		category.Size = UDim2.new(1, -40, 0, contentSize.Y + 50)
	end

	contentLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(updateSize)

	return contentFrame
end

local function createToggle(parent, text, callback)
	local toggleFrame = Instance.new("Frame")
	toggleFrame.Size = UDim2.new(1, 0, 0, 40)
	toggleFrame.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
	toggleFrame.BackgroundTransparency = 0.2
	toggleFrame.Parent = parent

	local toggleCorner = Instance.new("UICorner")
	toggleCorner.CornerRadius = UDim.new(0, 8)
	toggleCorner.Parent = toggleFrame

	local checkbox = Instance.new("TextButton")
	checkbox.Size = UDim2.new(0, 20, 0, 20)
	checkbox.Position = UDim2.new(0, 15, 0.5, -10)
	checkbox.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
	checkbox.Text = ""
	checkbox.Parent = toggleFrame

	local checkCorner = Instance.new("UICorner")
	checkCorner.CornerRadius = UDim.new(0, 4)
	checkCorner.Parent = checkbox

	local label = Instance.new("TextLabel")
	label.Size = UDim2.new(1, -50, 1, 0)
	label.Position = UDim2.new(0, 45, 0, 0)
	label.BackgroundTransparency = 1
	label.Text = text
	label.Font = Enum.Font.SourceSans
	label.TextSize = 14
	label.TextColor3 = Color3.fromRGB(255, 255, 255)
	label.TextXAlignment = Enum.TextXAlignment.Left
	label.Parent = toggleFrame

	local enabled = false

	checkbox.MouseButton1Click:Connect(function()
		enabled = not enabled
		if enabled then
			checkbox.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
		else
			checkbox.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
		end
		if callback then callback(enabled) end
	end)

	return toggleFrame
end

-- Players Page
local playersCategory = createCategory(playersPage, "Lista de Jogadores")

local searchBox = Instance.new("TextBox")
searchBox.Size = UDim2.new(1, 0, 0, 35)
searchBox.BackgroundColor3 = Color3.fromRGB(40, 40, 48)
searchBox.TextColor3 = Color3.fromRGB(255, 255, 255)
searchBox.PlaceholderText = "Pesquisar jogador..."
searchBox.Font = Enum.Font.SourceSans
searchBox.TextSize = 14
searchBox.Parent = playersCategory

local searchCorner = Instance.new("UICorner")
searchCorner.CornerRadius = UDim.new(0, 8)
searchCorner.Parent = searchBox



-- Container for players list and actions
local playersContainer = Instance.new("Frame")
playersContainer.Size = UDim2.new(1, 0, 0, 350)
playersContainer.BackgroundTransparency = 1
playersContainer.Parent = playersCategory

local playersList = Instance.new("ScrollingFrame")
playersList.Size = UDim2.new(0.6, -5, 1, 0) -- 60% width
playersList.Position = UDim2.new(0, 0, 0, 0)
playersList.BackgroundColor3 = Color3.fromRGB(32, 32, 38)
playersList.BorderSizePixel = 0
playersList.ScrollBarThickness = 6
playersList.Parent = playersContainer

local playersCorner = Instance.new("UICorner")
playersCorner.CornerRadius = UDim.new(0, 8)
playersCorner.Parent = playersList

local playersLayout = Instance.new("UIListLayout")
playersLayout.Padding = UDim.new(0, 4)
playersLayout.Parent = playersList

playersLayout:GetPropertyChangedSignal("AbsoluteContentSize"):Connect(function()
	playersList.CanvasSize = UDim2.new(0, 0, 0, playersLayout.AbsoluteContentSize.Y)
end)

-- Actions panel on the right
local actionsPanel = Instance.new("Frame")
actionsPanel.Size = UDim2.new(0.35, -5, 1, 0) -- 35% width
actionsPanel.Position = UDim2.new(0.65, 5, 0, 0)
actionsPanel.BackgroundColor3 = Color3.fromRGB(30, 30, 70)
actionsPanel.BackgroundTransparency = 0.4
actionsPanel.Parent = playersContainer

local actionsCorner = Instance.new("UICorner")
actionsCorner.CornerRadius = UDim.new(0, 12)
actionsCorner.Parent = actionsPanel

local actionsTitle = Instance.new("TextLabel")
actionsTitle.Size = UDim2.new(1, -20, 0, 30)
actionsTitle.Position = UDim2.new(0, 10, 0, 10)
actionsTitle.BackgroundTransparency = 1
actionsTitle.Text = "A√á√ïES DO JOGADOR"
actionsTitle.Font = Enum.Font.SourceSansBold
actionsTitle.TextSize = 14
actionsTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
actionsTitle.TextXAlignment = Enum.TextXAlignment.Left
actionsTitle.Parent = actionsPanel

local actionsContainer = Instance.new("Frame")
actionsContainer.Size = UDim2.new(1, -20, 1, -50)
actionsContainer.Position = UDim2.new(0, 10, 0, 40)
actionsContainer.BackgroundTransparency = 1
actionsContainer.Parent = actionsPanel

local actionsLayout = Instance.new("UIListLayout")
actionsLayout.Padding = UDim.new(0, 8)
actionsLayout.Parent = actionsContainer

local tpBtn = Instance.new("TextButton")
tpBtn.Size = UDim2.new(1, 0, 0, 40)
tpBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
tpBtn.BackgroundTransparency = 0.2
tpBtn.Text = "TELEPORTAR"
tpBtn.Font = Enum.Font.SourceSans
tpBtn.TextSize = 14
tpBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
tpBtn.Parent = actionsContainer
Instance.new("UICorner", tpBtn).CornerRadius = UDim.new(0, 8)

tpBtn.MouseButton1Click:Connect(function()
	if selectedPlayer then
		instantTPTo(selectedPlayer)
	end
end)

local spectateBtn = createToggle(actionsContainer, "ESPECTAR", function()
	if spectating == selectedPlayer then
		stopSpectate()
	else
		if selectedPlayer then startSpectate(selectedPlayer) end
	end
end)

local grabBtn = createToggle(actionsContainer, "AGARRAR", function()
	if selectedPlayer then startGrab(selectedPlayer) end
end)

local bugBtn = createToggle(actionsContainer, "BUGAR PLAYER", function()
	if selectedPlayer then
		if buggingPlayers[selectedPlayer] then
			stopBugPlayer(selectedPlayer)
		else
			startBugPlayer(selectedPlayer)
		end
	end
end)

-- Hide action buttons initially
tpBtn.Visible = false
spectateBtn.Visible = false
grabBtn.Visible = false
bugBtn.Visible = false

-- ESP Page
local espCategory = createCategory(espPage, "ESP Settings")

local espToggle = createToggle(espCategory, "ESP Ativado", function(enabled)
	espEnabled = enabled
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

local nameToggle = createToggle(espCategory, "Mostrar Nome", function(enabled)
	showName = enabled
end)

local healthToggle = createToggle(espCategory, "Mostrar Vida", function(enabled)
	showHealth = enabled
end)

local modeBtn = Instance.new("TextButton")
modeBtn.Size = UDim2.new(1, 0, 0, 40)
modeBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
modeBtn.BackgroundTransparency = 0.2
modeBtn.Text = "Modo: " .. espMode
modeBtn.Font = Enum.Font.SourceSans
modeBtn.TextSize = 14
modeBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
modeBtn.Parent = espCategory
Instance.new("UICorner", modeBtn).CornerRadius = UDim.new(0, 8)

modeBtn.MouseButton1Click:Connect(function()
	espMode = (espMode == "Cheio") and "Bordas" or "Cheio"
	modeBtn.Text = "Modo: " .. espMode
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

local autoEspToggle = createToggle(espCategory, "ESP Autom√°tico (Vis√≠vel/Invis√≠vel)", function(enabled)
	espAutoEnabled = enabled
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- ESP Position Selector
local positionBtn = Instance.new("TextButton")
positionBtn.Size = UDim2.new(1, 0, 0, 40)
positionBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
positionBtn.BackgroundTransparency = 0.2
positionBtn.Text = "Posi√ß√£o: " .. espPosition
positionBtn.Font = Enum.Font.SourceSans
positionBtn.TextSize = 14
positionBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
positionBtn.Parent = espCategory
Instance.new("UICorner", positionBtn).CornerRadius = UDim.new(0, 8)

positionBtn.MouseButton1Click:Connect(function()
	if espPosition == "Topo" then
		espPosition = "Baixo"
	elseif espPosition == "Baixo" then
		espPosition = "Lado"
	else
		espPosition = "Topo"
	end
	positionBtn.Text = "Posi√ß√£o: " .. espPosition
	for _, p in ipairs(Players:GetPlayers()) do refreshESPForPlayer(p) end
end)

-- Aimbot Page
local rageCategory = createCategory(aimbotPage, "Aimbot")

local aimbotToggle = createToggle(rageCategory, "Aimbot", function(enabled)
	aimbotEnabled = enabled
end)

local fovToggle = createToggle(rageCategory, "Mostrar FOV", function(enabled)
	aimbotShowFOV = enabled
	local existing = gui:FindFirstChild("FOVCircle")
	if aimbotShowFOV then
		if not existing then
			local fovCircle = Instance.new("Frame")
			fovCircle.Name = "FOVCircle"
			fovCircle.Size = UDim2.fromOffset(aimbotFOV * 2, aimbotFOV * 2)
			fovCircle.Position = UDim2.new(0.5, -aimbotFOV, 0.5, -aimbotFOV)
			fovCircle.BackgroundTransparency = 1
			fovCircle.BorderSizePixel = 2
			fovCircle.BorderColor3 = Color3.fromRGB(0, 170, 255)
			Instance.new("UICorner", fovCircle).CornerRadius = UDim.new(1, 0)
			fovCircle.Parent = gui
		end
	else
		if existing then existing:Destroy() end
	end
end)

local fovZeroToggle = createToggle(rageCategory, "Mostrar FOV Zero", function(enabled)
	aimbotShowFOVZero = enabled
	local existing = gui:FindFirstChild("FOVZeroCircle")
	if aimbotShowFOVZero then
		if not existing then
			local fovZeroCircle = Instance.new("Frame")
			fovZeroCircle.Name = "FOVZeroCircle"
			fovZeroCircle.Size = UDim2.fromOffset(aimbotFOVZero * 2, aimbotFOVZero * 2)
			fovZeroCircle.Position = UDim2.new(0.5, -aimbotFOVZero, 0.5, -aimbotFOVZero)
			fovZeroCircle.BackgroundTransparency = 1
			fovZeroCircle.BorderSizePixel = 2
			fovZeroCircle.BorderColor3 = Color3.fromRGB(255, 0, 255) -- Magenta for zero FOV
			Instance.new("UICorner", fovZeroCircle).CornerRadius = UDim.new(1, 0)
			fovZeroCircle.Parent = gui
		end
	else
		if existing then existing:Destroy() end
	end
end)

local visibleToggle = createToggle(rageCategory, "Apenas Vis√≠veis", function(enabled)
	aimbotOnlyVisible = enabled
end)

local npcToggle = createToggle(rageCategory, "Mirar NPCs", function(enabled)
	aimbotOnNPCs = enabled
end)

-- FOV Slider
local fovTitle = Instance.new("TextLabel")
fovTitle.BackgroundTransparency = 1
fovTitle.Size = UDim2.new(1, 0, 0, 25)
fovTitle.Font = Enum.Font.SourceSansBold
fovTitle.TextSize = 16
fovTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
fovTitle.Text = "FOV Slider"
fovTitle.Parent = rageCategory

local fovLabel = Instance.new("TextLabel")
fovLabel.BackgroundTransparency = 1
fovLabel.Size = UDim2.new(1, 0, 0, 20)
fovLabel.Font = Enum.Font.SourceSans
fovLabel.TextSize = 14
fovLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
fovLabel.Text = "FOV: " .. aimbotFOV
fovLabel.Parent = rageCategory

local fovSlider = Instance.new("Frame")
fovSlider.Size = UDim2.new(1, 0, 0, 12)
fovSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
fovSlider.Parent = rageCategory
Instance.new("UICorner", fovSlider).CornerRadius = UDim.new(0, 6)

local fovFill = Instance.new("Frame")
fovFill.Size = UDim2.fromScale((aimbotFOV - 50) / 200, 1)
fovFill.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
fovFill.Parent = fovSlider
Instance.new("UICorner", fovFill).CornerRadius = UDim.new(0, 6)

local fovDragging = false
fovSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		fovDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		fovDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if fovDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = fovSlider.AbsolutePosition
		local sliderSize = fovSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		aimbotFOV = math.floor(50 + relativeX * 200)
		fovLabel.Text = "FOV: " .. aimbotFOV
		fovFill.Size = UDim2.fromScale(relativeX, 1)
		local existing = gui:FindFirstChild("FOVCircle")
		if existing then
			existing.Size = UDim2.fromOffset(aimbotFOV * 2, aimbotFOV * 2)
			existing.Position = UDim2.new(0.5, -aimbotFOV, 0.5, -aimbotFOV)
		end
	end
end)

-- Smooth Slider
local smoothTitle = Instance.new("TextLabel")
smoothTitle.BackgroundTransparency = 1
smoothTitle.Size = UDim2.new(1, 0, 0, 25)
smoothTitle.Font = Enum.Font.SourceSansBold
smoothTitle.TextSize = 16
smoothTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
smoothTitle.Text = "Smooth Slider"
smoothTitle.Parent = rageCategory

local smoothLabel = Instance.new("TextLabel")
smoothLabel.BackgroundTransparency = 1
smoothLabel.Size = UDim2.new(1, 0, 0, 20)
smoothLabel.Font = Enum.Font.SourceSans
smoothLabel.TextSize = 14
smoothLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
smoothLabel.Text = "Smooth: " .. aimbotSmooth
smoothLabel.Parent = rageCategory

local smoothSlider = Instance.new("Frame")
smoothSlider.Size = UDim2.new(1, 0, 0, 12)
smoothSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
smoothSlider.Parent = rageCategory
Instance.new("UICorner", smoothSlider).CornerRadius = UDim.new(0, 6)

local smoothFill = Instance.new("Frame")
smoothFill.Size = UDim2.fromScale((aimbotSmooth - 1) / 9, 1)
smoothFill.BackgroundColor3 = Color3.fromRGB(236, 72, 153)
smoothFill.Parent = smoothSlider
Instance.new("UICorner", smoothFill).CornerRadius = UDim.new(0, 6)

local smoothDragging = false
smoothSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		smoothDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		smoothDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if smoothDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = smoothSlider.AbsolutePosition
		local sliderSize = smoothSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		aimbotSmooth = math.floor(1 + relativeX * 9)
		smoothLabel.Text = "Smooth: " .. aimbotSmooth
		smoothFill.Size = UDim2.fromScale(relativeX, 1)
	end
end)

-- Bind Button
local bindBtn = Instance.new("TextButton")
bindBtn.Size = UDim2.new(1, 0, 0, 40)
bindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
bindBtn.BackgroundTransparency = 0.2
bindBtn.Text = "Bind: " .. aimbotBindString
bindBtn.Font = Enum.Font.SourceSans
bindBtn.TextSize = 14
bindBtn.TextColor3 = Color3.fromRGB(255, 255, 255)
bindBtn.Parent = rageCategory
Instance.new("UICorner", bindBtn).CornerRadius = UDim.new(0, 8)

local bindListening = false
bindBtn.MouseButton1Click:Connect(function()
	bindListening = true
	bindBtn.Text = "Press any key..."
	bindBtn.BackgroundColor3 = Color3.fromRGB(255, 200, 0)
end)

UserInputService.InputBegan:Connect(function(input, processed)
	if bindListening and not processed then
		if input.UserInputType == Enum.UserInputType.Keyboard then
			aimbotBind = input.KeyCode
			aimbotBindString = input.KeyCode.Name
		elseif input.UserInputType == Enum.UserInputType.MouseButton1 then
			aimbotBind = "MouseLeft"
			aimbotBindString = "MouseLeft"
		elseif input.UserInputType == Enum.UserInputType.MouseButton2 then
			aimbotBind = "MouseRight"
			aimbotBindString = "MouseRight"
		elseif input.UserInputType == Enum.UserInputType.MouseButton3 then
			aimbotBind = "MouseMiddle"
			aimbotBindString = "MouseMiddle"
		else
			return -- Ignore other inputs
		end
		bindBtn.Text = "Bind: " .. aimbotBindString
		bindBtn.BackgroundColor3 = Color3.fromRGB(80, 50, 150)
		bindListening = false
	end
end)

-- Util Page
local miscCategory = createCategory(utilPage, "Utilit√°rios")

local flyToggle = createToggle(miscCategory, "Fly (F)", function(enabled)
	if enabled then toggleFly() end
end)

local noclipToggle = createToggle(miscCategory, "Noclip", function(enabled)
	noclip = enabled
end)

local speedToggle = createToggle(miscCategory, "Speed Boost", function(enabled)
	speedBoostEnabled = enabled
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if enabled then
				originalWalkSpeed = humanoid.WalkSpeed
				humanoid.WalkSpeed = speedBoostValue
			else
				humanoid.WalkSpeed = originalWalkSpeed
			end
		end
	end
end)

local jumpToggle = createToggle(miscCategory, "Jump Power Boost", function(enabled)
	jumpPowerBoostEnabled = enabled
	local character = LocalPlayer.Character
	if character then
		local humanoid = character:FindFirstChildOfClass("Humanoid")
		if humanoid then
			if enabled then
				originalJumpPower = humanoid.JumpPower
				humanoid.JumpPower = jumpPowerBoostValue
			else
				humanoid.JumpPower = originalJumpPower
			end
		end
	end
end)

local infiniteJumpToggle = createToggle(miscCategory, "Infinite Jump", function(enabled)
	infiniteJumpEnabled = enabled
	if enabled then
		UserInputService.JumpRequest:Connect(function()
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid:ChangeState(Enum.HumanoidStateType.Jumping)
				end
			end
		end)
	end
end)

local antiKickToggle = createToggle(miscCategory, "Anti-Kick", function(enabled)
	antiKickEnabled = enabled
	if enabled then
		local mt = getrawmetatable(game)
		local old = mt.__namecall
		setreadonly(mt, false)
		mt.__namecall = newcclosure(function(self, ...)
			local args = {...}
			local method = getnamecallmethod()
			if method == "Kick" then
				return nil
			end
			return old(self, ...)
		end)
		setreadonly(mt, true)
	end
end)

-- Speed Boost Slider
local speedTitle = Instance.new("TextLabel")
speedTitle.BackgroundTransparency = 1
speedTitle.Size = UDim2.new(1, 0, 0, 25)
speedTitle.Font = Enum.Font.SourceSansBold
speedTitle.TextSize = 16
speedTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
speedTitle.Text = "Speed Boost Slider"
speedTitle.Parent = miscCategory

local speedLabel = Instance.new("TextLabel")
speedLabel.BackgroundTransparency = 1
speedLabel.Size = UDim2.new(1, 0, 0, 20)
speedLabel.Font = Enum.Font.SourceSans
speedLabel.TextSize = 14
speedLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
speedLabel.Text = "Speed: " .. speedBoostValue
speedLabel.Parent = miscCategory

local speedSlider = Instance.new("Frame")
speedSlider.Size = UDim2.new(1, 0, 0, 12)
speedSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
speedSlider.Parent = miscCategory
Instance.new("UICorner", speedSlider).CornerRadius = UDim.new(0, 6)

local speedFill = Instance.new("Frame")
speedFill.Size = UDim2.fromScale((speedBoostValue - 16) / 84, 1)
speedFill.BackgroundColor3 = Color3.fromRGB(139, 92, 246)
speedFill.Parent = speedSlider
Instance.new("UICorner", speedFill).CornerRadius = UDim.new(0, 6)

local speedDragging = false
speedSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		speedDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		speedDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if speedDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = speedSlider.AbsolutePosition
		local sliderSize = speedSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		speedBoostValue = math.floor(16 + relativeX * 84)
		speedLabel.Text = "Speed: " .. speedBoostValue
		speedFill.Size = UDim2.fromScale(relativeX, 1)
		if speedBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.WalkSpeed = speedBoostValue
				end
			end
		end
	end
end)

-- Jump Power Slider
local jumpTitle = Instance.new("TextLabel")
jumpTitle.BackgroundTransparency = 1
jumpTitle.Size = UDim2.new(1, 0, 0, 25)
jumpTitle.Font = Enum.Font.SourceSansBold
jumpTitle.TextSize = 16
jumpTitle.TextColor3 = Color3.fromRGB(196, 181, 253)
jumpTitle.Text = "Jump Power Slider"
jumpTitle.Parent = miscCategory

local jumpLabel = Instance.new("TextLabel")
jumpLabel.BackgroundTransparency = 1
jumpLabel.Size = UDim2.new(1, 0, 0, 20)
jumpLabel.Font = Enum.Font.SourceSans
jumpLabel.TextSize = 14
jumpLabel.TextColor3 = Color3.fromRGB(255, 255, 255)
jumpLabel.Text = "Jump: " .. jumpPowerBoostValue
jumpLabel.Parent = miscCategory

local jumpSlider = Instance.new("Frame")
jumpSlider.Size = UDim2.new(1, 0, 0, 12)
jumpSlider.BackgroundColor3 = Color3.fromRGB(60, 60, 70)
jumpSlider.Parent = miscCategory
Instance.new("UICorner", jumpSlider).CornerRadius = UDim.new(0, 6)

local jumpFill = Instance.new("Frame")
jumpFill.Size = UDim2.fromScale((jumpPowerBoostValue - 50) / 150, 1)
jumpFill.BackgroundColor3 = Color3.fromRGB(236, 72, 153)
jumpFill.Parent = jumpSlider
Instance.new("UICorner", jumpFill).CornerRadius = UDim.new(0, 6)

local jumpDragging = false
jumpSlider.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		jumpDragging = true
	end
end)
UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		jumpDragging = false
	end
end)
UserInputService.InputChanged:Connect(function(input)
	if jumpDragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local mousePos = UserInputService:GetMouseLocation()
		local sliderPos = jumpSlider.AbsolutePosition
		local sliderSize = jumpSlider.AbsoluteSize
		local relativeX = math.clamp((mousePos.X - sliderPos.X) / sliderSize.X, 0, 1)
		jumpPowerBoostValue = math.floor(50 + relativeX * 150)
		jumpLabel.Text = "Jump: " .. jumpPowerBoostValue
		jumpFill.Size = UDim2.fromScale(relativeX, 1)
		if jumpPowerBoostEnabled then
			local character = LocalPlayer.Character
			if character then
				local humanoid = character:FindFirstChildOfClass("Humanoid")
				if humanoid then
					humanoid.JumpPower = jumpPowerBoostValue
				end
			end
		end
	end
end)

-- Make draggable
local dragging = false
local dragStart = nil
local startPos = nil

header.InputBegan:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = true
		dragStart = input.Position
		startPos = mainFrame.Position
	end
end)

UserInputService.InputChanged:Connect(function(input)
	if dragging and input.UserInputType == Enum.UserInputType.MouseMovement then
		local delta = input.Position - dragStart
		mainFrame.Position = UDim2.new(startPos.X.Scale, startPos.X.Offset + delta.X, startPos.Y.Scale, startPos.Y.Offset + delta.Y)
	end
end)

UserInputService.InputEnded:Connect(function(input)
	if input.UserInputType == Enum.UserInputType.MouseButton1 then
		dragging = false
	end
end)

-- Tab connections
tabPlayers.MouseButton1Click:Connect(function() setTab("PLAYERS") end)
tabESP.MouseButton1Click:Connect(function() setTab("ESP") end)
tabAimbot.MouseButton1Click:Connect(function() setTab("AIMBOT") end)
tabUtil.MouseButton1Click:Connect(function() setTab("UTIL") end)

-- Mostrar/ocultar painel
local function showPanel(show: boolean)
	if panelVisible == show then return end
	panelVisible = show
	mainFrame.Visible = show

	if show then
		-- Salvar estado atual do mouse
		prevMouseBehavior = UserInputService.MouseBehavior
		prevMouseIconEnabled = UserInputService.MouseIconEnabled

		-- Liberar mouse para usar a interface
		UserInputService.MouseBehavior = Enum.MouseBehavior.Default
		UserInputService.MouseIconEnabled = true

		-- Atualizar lista de players quando abrir o painel
		rebuildPlayersList()
	else
		-- Restaurar estado do mouse quando fechar
		if prevMouseBehavior then
				UserInputService.MouseBehavior = prevMouseBehavior
		end
		if prevMouseIconEnabled ~= nil then
				UserInputService.MouseIconEnabled = prevMouseIconEnabled
		end
	end
end

-- Fun√ß√£o para criar player buttons
local function addPlayerToRow(p: Player)
	if p == LocalPlayer then return end

	local playerBtn = Instance.new("TextButton")
	playerBtn.Name = p.Name
	playerBtn.Size = UDim2.new(1, -8, 0, 40)
	playerBtn.BackgroundColor3 = Color3.fromRGB(36,36,44)
	playerBtn.Text = ""
	playerBtn.Parent = playersList
	Instance.new("UICorner", playerBtn).CornerRadius = UDim.new(0, 6)

	local nameLbl = Instance.new("TextLabel")
	nameLbl.BackgroundTransparency = 1
	nameLbl.Size = UDim2.new(1, -8, 1, 0)
	nameLbl.Position = UDim2.new(0, 8, 0, 0)
	nameLbl.Font = Enum.Font.GothamSemibold
	nameLbl.TextSize = 14
	nameLbl.TextColor3 = Color3.fromRGB(255,255,255)
	nameLbl.TextXAlignment = Enum.TextXAlignment.Left

	nameLbl.Text = p.Name
	nameLbl.Parent = playerBtn

	local selectionIndicator = Instance.new("Frame")
	selectionIndicator.Size = UDim2.new(0, 4, 1, -8)
	selectionIndicator.Position = UDim2.new(0, 2, 0, 4)
	selectionIndicator.BackgroundColor3 = Color3.fromRGB(0, 170, 255)
	selectionIndicator.Visible = false
	selectionIndicator.Parent = playerBtn
	Instance.new("UICorner", selectionIndicator).CornerRadius = UDim.new(0, 2)

	playerBtn.MouseButton1Click:Connect(function()
		-- Desselecionar anterior
		for _, btn in ipairs(playersList:GetChildren()) do
			if btn:IsA("TextButton") and btn:FindFirstChildOfClass("Frame") then
				btn:FindFirstChildOfClass("Frame").Visible = false
				btn.BackgroundColor3 = Color3.fromRGB(36,36,44)
			end
		end

		-- Se j√° estava selecionado, deselecionar
		if selectedPlayer == p then
			selectedPlayer = nil
			stopSpectate()
			-- Hide action buttons
			tpBtn.Visible = false
			spectateBtn.Visible = false
			grabBtn.Visible = false
			bugBtn.Visible = false
			return
		end

		-- Selecionar atual
		selectionIndicator.Visible = true
		playerBtn.BackgroundColor3 = Color3.fromRGB(50,50,60)
		selectedPlayer = p

		-- Show action buttons
		tpBtn.Visible = true
		spectateBtn.Visible = true
		grabBtn.Visible = true
		bugBtn.Visible = true
	end)

	return playerBtn
end

local function clearPlayersList()
	for _, c in ipairs(playersList:GetChildren()) do
		if c:IsA("TextButton") then c:Destroy() end
	end
end

local function rebuildPlayersList()
    -- Limpa itens antigos
    clearPlayersList()

    -- Cria novos itens
    for _, plr in ipairs(Players:GetPlayers()) do
        if plr ~= LocalPlayer then
            addPlayerToRow(plr)
        end
    end

    -- Ajusta o tamanho da rolagem
    playersList.CanvasSize = UDim2.new(0, 0, 0, playersLayout.AbsoluteContentSize.Y)
end

Players.PlayerAdded:Connect(function(p)
	rebuildPlayersList()
end)

Players.PlayerRemoving:Connect(function(p)
	if selectedPlayer == p then
		selectedPlayer = nil
	end
	rebuildPlayersList()
end)

-- Aimbot Logic
local function getClosestPlayer()
	if not aimbotEnabled then return nil end
	
	local closestPlayer = nil
	local closestDistance = aimbotFOV
	
	local camera = workspace.CurrentCamera
	local mousePos = UserInputService:GetMouseLocation()
	
	for _, player in ipairs(Players:GetPlayers()) do
		if player ~= LocalPlayer and player.Character then
			local character = player.Character
			local head = character:FindFirstChild("Head")
			if head then
				local screenPos, onScreen = camera:WorldToViewportPoint(head.Position)
				if onScreen then
					local distance = (Vector2.new(screenPos.X, screenPos.Y) - mousePos).Magnitude
					if distance <= closestDistance then
						if aimbotOnlyVisible then
							local myChar = LocalPlayer.Character
							if myChar then
								local myRoot = myChar:FindFirstChild("HumanoidRootPart")
								local targetRoot = character:FindFirstChild("HumanoidRootPart")
								if myRoot and targetRoot then
									local raycastResult = workspace:Raycast(myRoot.Position, (targetRoot.Position - myRoot.Position).Unit * (targetRoot.Position - myRoot.Position).Magnitude)
									if raycastResult and raycastResult.Instance and not raycastResult.Instance:IsDescendantOf(character) then
										continue -- Not visible
									end
								end
							end
						end
						closestDistance = distance
						closestPlayer = player
					end
				end
			end
		end
	end
	
	return closestPlayer
end

-- Aimbot aim function
local function aimAt(targetPlayer)
	if not targetPlayer or not targetPlayer.Character then return end
	
	local camera = workspace.CurrentCamera
	local head = targetPlayer.Character:FindFirstChild("Head")
	if not head then return end
	
	local targetPos = head.Position
	local currentCFrame = camera.CFrame
	local targetCFrame = CFrame.new(currentCFrame.Position, targetPos)
	
	local smoothFactor = aimbotSmooth / 10
	if smoothFactor < 0.1 then smoothFactor = 0.1 end
	
	camera.CFrame = currentCFrame:Lerp(targetCFrame, smoothFactor)
end

-- Aimbot activation - custom bind
local aimbotKeyHeld = false

UserInputService.InputBegan:Connect(function(input, processed)
	if processed or not aimbotEnabled then return end
	
	local shouldActivate = false
	if aimbotBindString == "MouseLeft" and input.UserInputType == Enum.UserInputType.MouseButton1 then
		shouldActivate = true
	elseif aimbotBindString == "MouseRight" and input.UserInputType == Enum.UserInputType.MouseButton2 then
		shouldActivate = true
	elseif aimbotBindString == "MouseMiddle" and input.UserInputType == Enum.UserInputType.MouseButton3 then
		shouldActivate = true
	elseif input.KeyCode and input.KeyCode.Name == aimbotBindString then
		shouldActivate = true
	end
	
	if shouldActivate then
		aimbotKeyHeld = true
	end
end)

UserInputService.InputEnded:Connect(function(input, processed)
	if processed then return end
	
	local shouldDeactivate = false
	if aimbotBindString == "MouseLeft" and input.UserInputType == Enum.UserInputType.MouseButton1 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseRight" and input.UserInputType == Enum.UserInputType.MouseButton2 then
		shouldDeactivate = true
	elseif aimbotBindString == "MouseMiddle" and input.UserInputType == Enum.UserInputType.MouseButton3 then
		shouldDeactivate = true
	elseif input.KeyCode and input.KeyCode.Name == aimbotBindString then
		shouldDeactivate = true
	end
	
	if shouldDeactivate then
		aimbotKeyHeld = false
	end
end)

-- Continuous aiming when key/button held
RunService.RenderStepped:Connect(function()
	if aimbotKeyHeld and aimbotEnabled then
		local target = getClosestPlayer()
		if target then
			aimAt(target)
		end
	end
end)

-- Boot
local success, err = pcall(function()
	rebuildPlayersList()
	for _, p in ipairs(Players:GetPlayers()) do
		if p ~= LocalPlayer and p.Character then
			refreshESPForPlayer(p)
		end
	end
end)

if success then
	print("‚úÖ Painel pronto! Sistema de Biblioteca - Selecione jogadores para ver a√ß√µes!")
	print("üîë CONTROLES: M (Abrir/Fechar) | P (Destravar Mouse) | F (Fly) | H (Agarrar) | X (Cancelar)")
	print("üöó NOVO: Sistema de Bugar Carros ativado!")
	print("‚òÅÔ∏è SISTEMA FLY/NOCLIP ORIGINAL INTEGRADO! VELOCIDADE INICIAL: 1")
else
	warn("‚ùå Erro ao inicializar painel: " .. tostring(err))
end

local function toggleAction(_, state, _)
	if state == Enum.UserInputState.Begin then
		showPanel(not panelVisible)
	end
	return Enum.ContextActionResult.Sink
end
ContextActionService:BindActionAtPriority("TogglePanel", toggleAction, false, 2000, UI_TOGGLE_KEY)

-- Input geral
UserInputService.InputBegan:Connect(function(input, processed)
	if processed then return end
	if input.KeyCode == UI_TOGGLE_KEY then
		showPanel(not panelVisible)
	elseif input.KeyCode == FREEFLY_TOGGLE_KEY then
		toggleFly()
	elseif input.KeyCode == CANCEL_FLY_KEY then
		cancelling = true
	elseif input.KeyCode == GRAB_TOGGLE_KEY then
		grabNearestPlayer()
	elseif input.KeyCode == UNLOCK_MOUSE_KEY then
		unlockMouse()
	end
end)
